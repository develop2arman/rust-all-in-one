<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust-All-In-One(A.R)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="rust/RUST.html"><strong aria-hidden="true">1.</strong> RUST</a></li><li class="chapter-item expanded "><a href="TEMPLATE.html"><strong aria-hidden="true">2.</strong> TEMPLATE</a></li><li class="chapter-item expanded "><a href="shared/SHARED.html"><strong aria-hidden="true">3.</strong> SHARED</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="borrowchecker/BORROWCHECKER.html"><strong aria-hidden="true">4.</strong> BORROWCHECKER</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowchecker/semantic/SEMANTIC.html"><strong aria-hidden="true">4.1.</strong> SEMANTIC</a></li><li class="chapter-item "><a href="borrowchecker/lifetime/LIFETIME.html"><strong aria-hidden="true">4.2.</strong> LIFETIME</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowchecker/lifetime/static/LIFETIME_STATIC.html"><strong aria-hidden="true">4.2.1.</strong> STATIC</a></li><li class="chapter-item "><a href="borrowchecker/lifetime/elision/LIFETIME_ELISION.html"><strong aria-hidden="true">4.2.2.</strong> ELISION</a></li><li class="chapter-item "><a href="borrowchecker/lifetime/dangling/LIFETIME_DANGLING.html"><strong aria-hidden="true">4.2.3.</strong> DANGLING</a></li><li class="chapter-item "><a href="borrowchecker/lifetime/generic/LIFETIME_GENERIC.html"><strong aria-hidden="true">4.2.4.</strong> GENERIC</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="benchmark/BENCHMARK.html"><strong aria-hidden="true">5.</strong> BENCHMARK</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="cpu/CPU.html"><strong aria-hidden="true">6.</strong> CPU</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="pointers/POINTERS.html"><strong aria-hidden="true">7.</strong> POINTERS</a></li><li class="chapter-item expanded "><a href="pointers/smartpointer/SMARTPOINTER.html"><strong aria-hidden="true">8.</strong> SMARTPOINTER</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pointers/smartpointer/compiletime/shared_owner_locally/rc/RC.html"><strong aria-hidden="true">8.1.</strong> RC</a></li><li class="chapter-item "><a href="pointers/smartpointer/compiletime/box/BOX.html"><strong aria-hidden="true">8.2.</strong> BOX</a></li><li class="chapter-item "><a href="pointers/smartpointer/runtime/shared_locally_mutability/ref-cell/REF_CELL.html"><strong aria-hidden="true">8.3.</strong> REF_CELL</a></li><li class="chapter-item "><a href="pointers/smartpointer/ops/OPS.html"><strong aria-hidden="true">8.4.</strong> OPS</a></li><li class="chapter-item "><a href="pointers/smartpointer/compiletime/cow/COW.html"><strong aria-hidden="true">8.5.</strong> COW</a></li><li class="chapter-item "><a href="thread/sync/arc/ARC.html"><strong aria-hidden="true">8.6.</strong> ARC</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="process/PROCESS.html"><strong aria-hidden="true">9.</strong> PROCESS</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="collection/COLLECTION.html"><strong aria-hidden="true">10.</strong> COLLECTION</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="collection/hashmap/HASHMAP.html"><strong aria-hidden="true">10.1.</strong> HASHMAP</a></li><li class="chapter-item "><a href="collection/slice/SLICE.html"><strong aria-hidden="true">10.2.</strong> SLICE</a></li><li class="chapter-item "><a href="collection/vec/VECTOR.html"><strong aria-hidden="true">10.3.</strong> VECTOR</a></li><li class="chapter-item "><a href="pointers/smartpointer/compiletime/shared_owner_locally/rc/linkedlist/LINKEDLIST.html"><strong aria-hidden="true">10.4.</strong> LINKEDLIST</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="commandline/COMMANDLINE.html"><strong aria-hidden="true">11.</strong> COMMANDLINE</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="data/DATA.html"><strong aria-hidden="true">12.</strong> DATA</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="data/operator/OPERATOR.html"><strong aria-hidden="true">12.1.</strong> OPERATOR</a></li><li class="chapter-item "><a href="data/convert/CONVERT.html"><strong aria-hidden="true">12.2.</strong> CONVERT</a></li><li class="chapter-item "><a href="data/io/IO.html"><strong aria-hidden="true">12.3.</strong> IO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="data/io/file/FILE.html"><strong aria-hidden="true">12.3.1.</strong> FILE</a></li></ol></li><li class="chapter-item "><a href="data/regex/REGEX.html"><strong aria-hidden="true">12.4.</strong> REGEX</a></li><li class="chapter-item "><a href="data/arithmetic/ARITHMETIC.html"><strong aria-hidden="true">12.5.</strong> ARITHMETIC</a></li><li class="chapter-item "><a href="data/serde/SERDE.html"><strong aria-hidden="true">12.6.</strong> SERDE</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="duplication/Duplication.html"><strong aria-hidden="true">13.</strong> Duplication</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="duplication/copy-clone/COPY-CLONE.html"><strong aria-hidden="true">13.1.</strong> COPY_CLONE</a></li></ol></li><li class="chapter-item expanded "><a href="pointers/smartpointer/compiletime/shared_owner/rc/RC.html"><strong aria-hidden="true">14.</strong> RC</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="errorhandling/ERROR_HANDLING.html"><strong aria-hidden="true">15.</strong> ERROR_HANDLING</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="errorhandling/non-recoverable/ERROR_NONRECOVERABLE.html"><strong aria-hidden="true">15.1.</strong> ERROR_NONRECOVERABLE</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="feature/FEATURE.html"><strong aria-hidden="true">16.</strong> FEATURE</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="flowcontrol/FLOWCONTROL.html"><strong aria-hidden="true">17.</strong> FLOWCONTROL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flowcontrol/for/FOR.html"><strong aria-hidden="true">17.1.</strong> FOR</a></li><li class="chapter-item "><a href="flowcontrol/loop/LOOP.html"><strong aria-hidden="true">17.2.</strong> LOOP</a></li><li class="chapter-item "><a href="flowcontrol/while/WHILE.html"><strong aria-hidden="true">17.3.</strong> WHILE</a></li><li class="chapter-item "><a href="flowcontrol/match/MATCH.html"><strong aria-hidden="true">17.4.</strong> MATCH</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="functional-programming/FUNC-PROG.html"><strong aria-hidden="true">18.</strong> FUNCTION PROGRAMMING</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functional-programming/closure/CLOSURE.html"><strong aria-hidden="true">18.1.</strong> CLOSURE</a></li><li class="chapter-item "><a href="functional-programming/function/FUNCTION.html"><strong aria-hidden="true">18.2.</strong> FUNCTION</a></li><li class="chapter-item "><a href="functional-programming/lazy/LAZY.html"><strong aria-hidden="true">18.3.</strong> LAZY</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="libc/LIBC.html"><strong aria-hidden="true">19.</strong> LIBC</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="network/NETWORK.html"><strong aria-hidden="true">20.</strong> NETWORK</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="oop/OOP.html"><strong aria-hidden="true">21.</strong> OOP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="oop/trait/TRAIT.html"><strong aria-hidden="true">21.1.</strong> TRAIT</a></li></ol></li><li class="chapter-item expanded "><a href="oop/design_patterns/DESIGN_PATTERN.html"><strong aria-hidden="true">22.</strong> DESIGN_PATTERN</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="oop/design_patterns/behavioral/state-pattern/STATE_PATTERN.html"><strong aria-hidden="true">22.1.</strong> STATE_PATTERN</a></li><li class="chapter-item "><a href="oop/design_patterns/behavioral/BEHAVIOARAL.html"><strong aria-hidden="true">22.2.</strong> BEHAVIOARAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="oop/design_patterns/behavioral/lpxxn/lpxxn-behavioral.html"><strong aria-hidden="true">22.2.1.</strong> LPXXN</a></li><li class="chapter-item "><a href="oop/design_patterns/behavioral/process/PROCESS.html"><strong aria-hidden="true">22.2.2.</strong> PROCESS</a></li></ol></li><li class="chapter-item "><a href="oop/design_patterns/creational/CREATIONAL.html"><strong aria-hidden="true">22.3.</strong> CREATIONAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="oop/design_patterns/creational/lpxxn/lpxxn-creational.html"><strong aria-hidden="true">22.3.1.</strong> LPXXN</a></li></ol></li><li class="chapter-item "><a href="oop/design_patterns/structural/STRUCTURAL.html"><strong aria-hidden="true">22.4.</strong> STRUCTRUAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="oop/design_patterns/structural/lpxxn/lpxxn-structural.html"><strong aria-hidden="true">22.4.1.</strong> LPXXN</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="trait/TRAIT.html"><strong aria-hidden="true">23.</strong> TRAIT</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/associate-type-or-trait/ASSOCIATE.html"><strong aria-hidden="true">23.1.</strong> ASSOCIATE</a></li><li class="chapter-item "><a href="trait/inheritance/INHERITANCE.html"><strong aria-hidden="true">23.2.</strong> INHERITANCE</a></li><li class="chapter-item "><a href="trait/built-in/BUILT_IN.html"><strong aria-hidden="true">23.3.</strong> BUILT-IN</a></li><li class="chapter-item "><a href="trait/shared-behavior/SHARED_BEHAVIOR.html"><strong aria-hidden="true">23.4.</strong> SHARED_BEHAVIOR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/shared-behavior/builtin-trait/BUILTIN-TRAIT.html"><strong aria-hidden="true">23.4.1.</strong> BUILTIN-TRAIT</a></li><li class="chapter-item "><a href="trait/shared-behavior/safe-object/SAFEOBJECT.html"><strong aria-hidden="true">23.4.2.</strong> SAFE OBJECT</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/shared-behavior/safe-object/dispatchable/TRAITOBJECT.html"><strong aria-hidden="true">23.4.2.1.</strong> TRAITOBJECT</a></li></ol></li><li class="chapter-item "><a href="trait/shared-behavior/none-object-safe/NONE_OBJECT_SAFE.html"><strong aria-hidden="true">23.4.3.</strong> NON_OBJECT_SAFE</a></li><li class="chapter-item "><a href="trait/shared-behavior/aggregator/AGGRIGATOR.html"><strong aria-hidden="true">23.4.4.</strong> AGGRIGATOR</a></li></ol></li><li class="chapter-item "><a href="trait/shared-behavior/trait-bound/TRAIT_BOUND.html"><strong aria-hidden="true">23.5.</strong> TRAIT_BOUND</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/shared-behavior/trait-bound/operator/OPERATOR.html"><strong aria-hidden="true">23.5.1.</strong> OPERATOR</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="types/M_TYPES.html"><strong aria-hidden="true">24.</strong> TYPES</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/generic/GENERIC.html"><strong aria-hidden="true">24.1.</strong> GENERIC</a></li><li class="chapter-item "><a href="types/return/RETURN.html"><strong aria-hidden="true">24.2.</strong> RETURN</a></li><li class="chapter-item "><a href="types/static/STATIC.html"><strong aria-hidden="true">24.3.</strong> STATIC</a></li><li class="chapter-item "><a href="types/wrapper/WRAPPER.html"><strong aria-hidden="true">24.4.</strong> WRAPPER</a></li><li class="chapter-item "><a href="types/rhs/RHS.html"><strong aria-hidden="true">24.5.</strong> RHS</a></li><li class="chapter-item "><a href="types/var/VAR.html"><strong aria-hidden="true">24.6.</strong> VAR</a></li><li class="chapter-item "><a href="types/mscal/M_SCAL.html"><strong aria-hidden="true">24.7.</strong> SCALAR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/mscal/numeric/NUMERIC.html"><strong aria-hidden="true">24.7.1.</strong> NUMERIC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/mscal/numeric/primitive/PRIMITIVE.html"><strong aria-hidden="true">24.7.1.1.</strong> PRIMITIVE</a></li><li class="chapter-item "><a href="types/mscal/numeric/num/NUM.html"><strong aria-hidden="true">24.7.1.2.</strong> NUM</a></li></ol></li><li class="chapter-item "><a href="types/mscal/non_numeric/NON_NUMERIC.html"><strong aria-hidden="true">24.7.2.</strong> NON_NUMERIC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/mscal/non_numeric/string/STRING.html"><strong aria-hidden="true">24.7.2.1.</strong> STRING</a></li><li class="chapter-item "><a href="types/mscal/non_numeric/char/CHAR.html"><strong aria-hidden="true">24.7.2.2.</strong> CHAR</a></li></ol></li></ol></li><li class="chapter-item "><a href="types/compound/COMPOUND.html"><strong aria-hidden="true">24.8.</strong> COMPOUND</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/compound/array/ARRAY.html"><strong aria-hidden="true">24.8.1.</strong> ARRAY</a></li><li class="chapter-item "><a href="types/compound/tuple/TUPLE.html"><strong aria-hidden="true">24.8.2.</strong> TUPLE</a></li><li class="chapter-item "><a href="types/compound/union/UNION.html"><strong aria-hidden="true">24.8.3.</strong> UNION</a></li><li class="chapter-item "><a href="types/compound/struct/STRUCT.html"><strong aria-hidden="true">24.8.4.</strong> STRUCT</a></li><li class="chapter-item "><a href="types/compound/enum/ENUM.html"><strong aria-hidden="true">24.8.5.</strong> ENUM</a></li><li class="chapter-item "><a href="types/compound/option/OPTION.html"><strong aria-hidden="true">24.8.6.</strong> OPTION</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="stdmisc/STDMISC.html"><strong aria-hidden="true">25.</strong> STDMISC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stdmisc/rust-doc/rd-thread-channel.html"><strong aria-hidden="true">25.1.</strong> thread-channel</a></li><li class="chapter-item "><a href="stdmisc/rust-doc/rd-path.html"><strong aria-hidden="true">25.2.</strong> path</a></li><li class="chapter-item "><a href="stdmisc/rust-doc/rd-file.html"><strong aria-hidden="true">25.3.</strong> file</a></li><li class="chapter-item "><a href="stdmisc/rust-doc/rd-filesystem.html"><strong aria-hidden="true">25.4.</strong> filesystem</a></li><li class="chapter-item "><a href="stdmisc/rust-doc/rd-command-process.html"><strong aria-hidden="true">25.5.</strong> command-process</a></li><li class="chapter-item "><a href="stdmisc/rust-doc/rd-ffi.html"><strong aria-hidden="true">25.6.</strong> ffi</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="thread/THREAD.html"><strong aria-hidden="true">26.</strong> THREAD</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="thread/race/RACE.html"><strong aria-hidden="true">26.1.</strong> RACE</a></li><li class="chapter-item "><a href="thread/rayon/RAYON.html"><strong aria-hidden="true">26.2.</strong> RAYON</a></li><li class="chapter-item "><a href="thread/sync/ATOMIC.html"><strong aria-hidden="true">26.3.</strong> Sync_Atomic_Mutex</a></li><li class="chapter-item "><a href="thread/mpsc/MPSC.html"><strong aria-hidden="true">26.4.</strong> MPSC</a></li><li class="chapter-item "><a href="thread/time/THREAD-TIME.html"><strong aria-hidden="true">26.5.</strong> THREAD_TIME</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="time/TIME.html"><strong aria-hidden="true">27.</strong> TIME</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="tests/TESTS.html"><strong aria-hidden="true">28.</strong> TEST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/test_structures/test-structures.html"><strong aria-hidden="true">28.1.</strong> Structures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/test_structures/test_unit/test-unit.html"><strong aria-hidden="true">28.1.1.</strong> Unit</a></li><li class="chapter-item "><a href="tests/test_structures/test_pretty/test-pretty.html"><strong aria-hidden="true">28.1.2.</strong> Pretty</a></li><li class="chapter-item "><a href="tests/test_structures/test_proptest/test-proptest.html"><strong aria-hidden="true">28.1.3.</strong> Proptest</a></li><li class="chapter-item "><a href="tests/test_structures/test_proptest_runner/test-proptest_runner.html"><strong aria-hidden="true">28.1.4.</strong> Proptest_runner</a></li><li class="chapter-item "><a href="tests/test_structures/test_fixture/test-fixture.html"><strong aria-hidden="true">28.1.5.</strong> Fixture</a></li></ol></li><li class="chapter-item "><a href="tests/tests_samples/test-samples.html"><strong aria-hidden="true">28.2.</strong> Samples</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="unsafe/UNSAFE.html"><strong aria-hidden="true">29.</strong> UNSAFE</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/extern-ffi/EXTERN-FFI.html"><strong aria-hidden="true">29.1.</strong> EXTERN_FFI</a></li><li class="chapter-item "><a href="unsafe/safe-abstraction/SAFE_ABSTRACTION.html"><strong aria-hidden="true">29.2.</strong> SAFE_ABSTRACTION</a></li><li class="chapter-item "><a href="unsafe/safe-static-mut/SAFE_STATIC_MUT.html"><strong aria-hidden="true">29.3.</strong> SAFE_STATIC_MUT</a></li><li class="chapter-item "><a href="unsafe/unsafe-thread/THREAD_UNSAFE.html"><strong aria-hidden="true">29.4.</strong> THREAD_UNSAFE</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="macro/MACRO.html"><strong aria-hidden="true">30.</strong> MACRO</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="module/MODULE.html"><strong aria-hidden="true">31.</strong> MOUDULE</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="memory/MEMORY.html"><strong aria-hidden="true">32.</strong> MEMORY</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory/allocator/ALLOCATOR.html"><strong aria-hidden="true">32.1.</strong> ALLOCATOR</a></li><li class="chapter-item "><a href="memory/piston/PISTON.html"><strong aria-hidden="true">32.2.</strong> PISTON</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="idioms/IDIOMS.html"><strong aria-hidden="true">33.</strong> IDIOMS</a></li><li class="chapter-item expanded "><a href="grammer/GRAMMER.html"><strong aria-hidden="true">34.</strong> GRAMMER</a></li><li class="chapter-item expanded "><a href="brain-teaser/BRAIN_TREASER.html"><strong aria-hidden="true">35.</strong> BRAIN_TREASER</a></li><li class="chapter-item expanded "><a href="questions/QUESTIONS.html"><strong aria-hidden="true">36.</strong> QUESTIONS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="questions/triplebyte/TBYTE.html"><strong aria-hidden="true">36.1.</strong> TBYTE</a></li></ol></li><li class="chapter-item expanded "><a href="algorithm/ALGORITHM.html"><strong aria-hidden="true">37.</strong> ALGORITHM</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust-All-In-One(A.R)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arman2develop/rust-all-in-one/tree/main/workspace" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://codecov.io/gh/arman2develop/rust-all-in-one"><img src="https://codecov.io/gh/arman2develop/rust-all-in-one/graph/badge.svg?token=7ed4c74c-b784-464a-a9fe-fbea6dcb4cb8" alt="codecov" /></a></p>
<!--
https://codecov.io/gh/arman2develop/rust-all-in-one/graphs/tree.svg?token=OXWKHZI4FP
-->
<hr />
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<details
<ul>
<li>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code> and <code>std</code>. </li>
<li><code>core</code> includes the most basic types and functions that don’t depend on <code>libc</code>, allocator or even the presence of an operating system. </li>
<li><code>alloc</code> includes types which require a global heap allocator, such as <code>Vec</code>, <code>Box</code> and <code>Arc</code>.</li>
<li>Embedded Rust applications often only use <code>core</code>, and sometimes <code>alloc</code>.</li>
</ul>
</details
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p><code>time cargo run</code></p>
<p><code>cargo doc  --workspace --message-format short --no-deps --open --color always</code></p>
<p><code>cargo test --doc --workspace</code></p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use-cases</a></h2>
<p>Hostile environments: In situations where <strong>safety</strong> is of utmost concern, Rust’s guarantees are a perfect fit.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Concurrent</li>
<li><input disabled="" type="checkbox" checked=""/>
Safe programming</li>
<li><input disabled="" type="checkbox" checked=""/>
Processing</li>
<li><input disabled="" type="checkbox" checked=""/>
Replacing legacy C or C++</li>
</ul>
<p>npm chose Rust to handle CPU-bound bottlenecks.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p><code>path</code>:	::</p>
<p><code>!</code>: that’s known in type theory lingo as the empty type because it has no values. We prefer to call it the never type.Functions that return never are called diverging functions.</p>
<p><code>?Sized</code>: T may or may not be Sized-Trait syntax with this meaning is only available for Sized, this notation overrides the default that generic types must have a known size at compile time. not any other traits.</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p><img src="rust/./assets/images/safety.png" alt="safetay-control" /></p>
<p>It guarantees that your program is memory-safe without imposing any runtime costs.</p>
<h3 id="goal-of-rust-safety"><a class="header" href="#goal-of-rust-safety">Goal of Rust: Safety</a></h3>
<p>Rust programs are free from:</p>
<ol>
<li>
<p><strong>Dangling pointers</strong>— &lt;u_Live references_&lt;/u to data that has become invalid over the course of the program (see [[ria-data-csv-bin]])</p>
</li>
<li>
<p><strong>Data races</strong>—The inability to determine how a program will behave from &lt;u_run to run_&lt;/u because external factors change (see [[pnkfx-mpsc]])</p>
</li>
<li>
<p><strong>Buffer overflow</strong>—An attempt to access the 12th element of an &lt;u_array_&lt;/u with only 6 elements </p>
</li>
<li>
<p><strong>Iterator invalidation</strong>—An issue caused by something that is iterated over after being &lt;u_altered midway_ through&lt;/u </p>
</li>
</ol>
<h2 id="foreign-function-interface-ffi"><a class="header" href="#foreign-function-interface-ffi">Foreign Function Interface (FFI)</a></h2>
<p>Rust’s Foreign Function Interface (FFI) capabilities enable seamless integration with existing C and C++ codebases. This feature is crucial for system development, as it allows Rust code to interact with libraries written in other languages. Rust’s <em>FFI guarantees safety, preventing issues like null pointer de-referencing that often occur in large C/C++ interactions.</em></p>
<h2 id="memory-model"><a class="header" href="#memory-model">Memory model</a></h2>
<h3 id="raii"><a class="header" href="#raii">RAII</a></h3>
<p>Rust uses [[RAII]] (resource acquisition is initialization) to keep track of when variables and all their references are in and out of scope. Once they are out of scope, memory can be released. The borrow checker will not allow references to out of scope variables, and it only allows one mutable reference or multiple immutable references, but never both.</p>
<h3 id="explicit"><a class="header" href="#explicit">Explicit</a></h3>
<h3 id="rust-programs-have-3-memory"><a class="header" href="#rust-programs-have-3-memory">Rust programs have 3 memory</a></h3>
<p>(regions where data is stored)</p>
<h4 id="data-memory"><a class="header" href="#data-memory">data memory</a></h4>
<p>For data that is fixed in size and static (i.e. always available through life of program). Consider the text in your program (e.g. “Hello World!”): This text’s bytes are only ever read from one place and therefore can be stored in this region. Compilers make lots of optimizations with this kind of data, and they are generally considered very fast to use since locations are known and fixed.</p>
<h4 id="stack-memory"><a class="header" href="#stack-memory">stack memory</a></h4>
<p>For data that is declared as variables within a function. The location of this memory never changes for the duration of a function call; because of this compilers can optimize code so stack data is very fast to access.</p>
<h4 id="heap-memory"><a class="header" href="#heap-memory">heap memory</a></h4>
<p>For data that is created while the application is running. Data in this region may be added, moved, removed, resized, etc. Because of its dynamic nature it’s generally considered slower to use, but it allows for much more creative usages of memory. When data is added to this region we call it an allocation. When data is removed from this section we call it a deallocation. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>String struct is also on stack,but holds a reference to data on heap</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let s= Struct{x:y,z:w}  
<span class="boring">}
</span></code></pre></pre>
<h2 id="numerous-community-tools"><a class="header" href="#numerous-community-tools">Numerous community tools</a></h2>
<p>(for improving code quality and productivity)</p>
<p>rust-clippy, an advanced linter and style tool - This warns you of common mistakes and potential <strong>code smells</strong>. Clippy relies on <strong>compiler plugins</strong> that are marked as unstable, so it is available with nightly Rust only. With rustup, you can switch to nightly easily.</p>
<p>rustfmt, an opinionated code formatter-It formats code according to conventions that are mentioned in the Rust style guide.
rust-analyzer, full-featured IDE integration for the Rust language</p>
<p><strong>sccache</strong>, a compiler cache for rustc.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>A test double is the general programming concept for a type used in place of another type during testing. Mock objects are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<h3 id="stdprelude"><a class="header" href="#stdprelude">std:prelude</a></h3>
<p>To understand what is included in local scope by default(like try_into()), you should investigate the std:: [[prelude]] module. Its documentation is available online at <a href="https://doc.rust-lang.org/std/prelude/index.html">prelude</a></p>
<h3 id="no_std"><a class="header" href="#no_std">no_std</a></h3>
<p>Finally, Rust is very well suited for embedded development and shellcodes. Because these environments don’t rely on a proper Operating System, you generally can’t use Rust’s standard library and you need to use the core library instead.</p>
<p>For these usecases, we use the #![no_std] attribute:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) - ! {
    loop {}
}

#[no_mangle]
fn _start() {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="method--func"><a class="header" href="#method--func">Method &amp; Func</a></h2>
<p>Methods are functions that are coupled to some object. From a syntactic point of view, these are just functions that don’t need to specify one of their arguments. Rather than calling open() and passing a File object in as an argument (read(f, buffer)), methods allow the main object to be implicit in the function call (f.read(buffer)) using the dot operator.1</p>
<p>There are a number of theoretical differences between methods and functions, but a detailed discussion of those computer science topics is available in other books. Briefly, functions are regarded as pure, meaning their behavior is determined solely by their arguments. </p>
<p>Methods are inherently impure, given that one of their arguments is effectively a side effect. These are muddy waters, though. Functions are perfectly capable of acting on side effects themselves. Moreover, methods are implemented with functions. And, to add an exception to an exception, objects sometimes implement static methods, which do not include implicit arguments.</p>
<p>To define methods, Rust programmers use an impl block</p>
<h2 id="zero-cost-abstractions"><a class="header" href="#zero-cost-abstractions">Zero-cost abstractions</a></h2>
<p>Rust empowers us to create high-level abstractions without sacrificing performance. This is achieved through the principle of “zero-cost abstractions”. Rust’s ownership and borrowing system, combined with its sophisticated compiler optimizations, allow code to be written in a natural and expressive way <strong>while still compiling to efficient machine code</strong>.
Let’s explore an example <em>illustrating non-zero cost abstraction</em> in Rust and compare it with a counterpart that lacks such abstraction. Consider a simple task of filtering even numbers from a vector:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_even_numbers_old(numbers: Vec&lt;i32) - Vec&lt;i32 {
  let mut result = Vec::new();
  for num in numbers {
    if num % 2 == 0 {
     result.push(num);
    }
  }
  result
}
<span class="boring">}
</span></code></pre></pre>
<p>we utilize the into_iter() method to create an iterator, apply the filter method with a closure defining the condition, and then collect the results into a new vector. This approach abstracts away the low-level iteration and conditional checking details, providing a cleaner and more readable implementation.</p>
<p>Example of Zero-cost abstraction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_even_numbers_new(numbers: Vec&lt;i32) - Vec&lt;i32 {
    numbers.into_iter().filter(|&amp;num| num % 2 == 0).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, the second example with zero cost abstraction offers several advantages. It <strong>encapsulates the filtering logic</strong> <em>in a more declarative style, making the intent clearer and</em> <strong>reducing the chances of introducing errors related to manual iteration and conditional checks</strong>. Moreover, it aligns with Rust’s emphasis on expressive and ergonomic code, enhancing readability and maintainability. By comparing both examples, you can appreciate how zero cost abstraction not only improves code aesthetics but also contributes to more robust, concise, and comprehensible solutions in Rust.</p>
<p>Consider another example showcasing Rust’s ownership system and how it allows safe and performant concurrent programming:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
fn main() {
  let data = vec![1, 2, 3, 4, 5];
  let shared_data = std::sync::Arc::new(data);
  let handles: Vec&lt;_ = (0..5).map(|i| {
  let shared_data = shared_data.clone();
    thread::spawn(move || {
      let local_sum: i32 = shared_data.iter().sum();
      println!(&quot;Thread {} Sum: {}&quot;, i, local_sum);
    })
}).collect();

  for handle in handles {
    handle.join().unwrap();
  }
}
// Output:
// Thread 0 Sum: 15
// Thread 2 Sum: 15
// Thread 4 Sum: 15
// Thread 1 Sum: 15
// Thread 3 Sum: 15
</code></pre></pre>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>Internally, Cargo uses the <strong>semver</strong> crate for parsing the versions</p>
<h2 id="glossery"><a class="header" href="#glossery">Glossery</a></h2>
<p><code>Uninhabited</code>: type is the never type !, or an enum with no variants enum Never { }. Opposite of Inhabited.</p>
<p><code>Crate</code>: A crate is the unit of compilation and linking. There are different types of crates, such as libraries or executables. Crates may link and refer to other library crates, called external crates. A crate has a self-contained tree of modules, starting from an unnamed root module called the crate root. Items may be made visible to other crates by marking them as public in the crate root, including through paths of public modules.</p>
<p><code>Module</code>: A module is a container for zero or more items. Modules are organized in a tree, starting from an unnamed module at the root called the crate root or the root module. Paths may be used to refer to items from other modules, which may be restricted by visibility rules.</p>
<p><code>Name</code> A name is an identifier or lifetime or loop label that refers to an entity. A name binding is when an entity declaration introduces an identifier or label associated with that entity. Paths, identifiers, and labels are used to refer to an entity.</p>
<p><code>Name resolution</code>: Name resolution is the compile-time process of tying paths, identifiers, and labels to entity declarations.</p>
<p><code>Namespace</code>: A namespace is a logical grouping of declared names based on the kind of entity the name refers to. Namespaces allow the occurrence of a name in one namespace to not conflict with the same name in another namespace. Within a namespace, names are organized in a hierarchy, where each level of the hierarchy has its own collection of named entities.</p>
<p><code>Prelude</code>: Prelude, or The Rust Prelude, is a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive.</p>
<p><code>Scope</code>: A scope is the region of source text where a named entity may be referenced with that name.</p>
<hr />
<h2 id="notations"><a class="header" href="#notations">Notations</a></h2>
<pre><pre class="playground"><code class="language-rust  compile_fail  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RArrow -
Eq/EqualArrow =
; Semi or SemiColon
: Colon
&lt; Cover, Angle Bracket
[] Square Bracket
() Parenthese
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><a href="https://doc.rust-lang.org/nightly/reference/glossary.html">Rust Glossary</a></p>
<p><a href="https://doc.rust-lang.org/reference/notation.html">Rust Notation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p><a href="rust/RUST.html">RUST</a></p>
<h1 id="template"><a class="header" href="#template">Template</a></h1>
<pre><code>/*
#![allow(dead_code, unused_variables)]
packtpub-string-bin-ex-1

## Commands

```cargo run -q -p packtpub-types-string_bin --bin packtpub-string-bin-ex-1```

## What
`TODO`

## How
`TODO`

# Arguments

* `Arg1` - This is the [your type] to [your verb] the [your struct/func name]

# Return
`assert:true`

## Example
 //```rust,compile_fail,ignore
*/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Core libs:</p>
</blockquote>
<ul>
<li>Iterator Stepper</li>
<li>String to u128</li>
<li>Stringify</li>
</ul>
<blockquote>
<p><code>tags</code> [[stepper]] [[iterator]] [[u128]] [[stringify]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[LIFETIME]]</p>
<p>[[SEMANTIC]]</p>
<p>[[OWNERSHIP]]</p>
<hr />
<p>Borrow checking relies on three interrelated concepts—<strong>lifetimes, ownership, and borrowing</strong>:</p>
<p>Ownership: the notion of ownership is rather limited. <strong>An owner cleans up when its values’ lifetimes end.</strong></p>
<p>For example, <em>when a function returns, the memory holding its local variables needs to be freed</em>. 
Owners cannot prevent other parts of the program from accessing their values or report data theft to some overarching Rust authority.the term move means something very specific within Rust. Nothing physically moves.Movement within Rust code <strong>refers to movement of ownership</strong>, rather than the movement of data. 
Ownership is a term used within the Rust community to <u>refer to the compile-time process that checks&lt;/uthat every use of a value is valid and that every value is destroyed cleanly.
ownership system provides a route to memory safety without needing a garbage collector. </p>
<p>Four general strategies can help with <strong>ownership issues</strong>:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Use references</strong> where full ownership is not required.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Duplicate</strong> the value.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Refactor</strong> code to reduce the number of long-lived objects.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Wrap</strong> your data in a type designed to assist with movement issues.</li>
</ul>
<p>To borrow: there is no obligation to return the value to its owner. Its meaning is used to emphasize that while values can have a <strong>single owner</strong>, it’s possible for many parts of the program to <strong>share access</strong> to those values.</p>
<hr />
<p>The borrow checker checks that all access to data is legal, which allows Rust to prevent safety issues. Learning how this works will, at the very least, speed up your development time by helping you avoid run-ins with the compiler. More significantly though, learning to work with the borrow checker allows you to build larger software systems with confidence.</p>
<p>It underpins the term <strong>fearless concurrency</strong></p>
<h2 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing Rules</a></h2>
<ul>
<li>A reference may not live longer than what it referred to. This is obvious, since if it did, it would be referring to a garbage value.</li>
<li>If there’s a mutable reference to a value, no other references, either mutable or immutable references, are allowed to the same value in that scope. A mutable reference is an exclusive borrow.</li>
<li>If there is no mutable reference to a thing, any number of immutable references to the same value are allowed in the scope.</li>
</ul>
<hr />
<p>To borrow a value means to access it. This terminology is somewhat confusing as there is no obligation to return the value to its owner. Its meaning is used to emphasize that while values can have a single owner, it’s possible for many parts of the program to share access to those values.</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Ownership is the methodology we use to handle <strong>memory safely without a garbage collector</strong>.</p>
<p>[[Ownership]] has a particular meaning within Rust. An owner is able to make any changes to the data and is responsible for deleting values that it owns when it leaves scope.</p>
<p>The ownership rule of Rust states the following principles:</p>
<p>When you create a value or a resource using the <strong>let</strong> statement and assign it to a variable, the variable becomes the owner of the resource When the value is reassigned from one variable to another, <strong>the ownership of the value moves to the other variable and the older variable becomes invalid</strong> for further use The value and the variable are deallocated at the end of their scope.</p>
<p>The ownership rule prevents you from having multiple points of access for modifying the value, which can lead to use after free situations, even in single threaded contexts with languages that permit multiple mutable aliases for values.</p>
<p>The drop and write {} method comes from the Drop trait, which is implemented for most heap allocated types in Rust and makes automatic freeing of resources a breeze.</p>
<hr />
<h2 id="glossery-1"><a class="header" href="#glossery-1">Glossery</a></h2>
<p><code>aliasing</code>: Having several immutable references (&amp;T) to the object (Rc).</p>
<p><code>mutability</code>: Having one mutable reference (&amp;mut T) to the object (mut Refcell).</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-semantic]]</p>
<p>[[mr-semantic]]</p>
<p>[[re-move-semantic]]</p>
<hr />
<p><em>primitive</em> types are said to possess <strong>copy semantics</strong>, whereas all <em>other types</em> have <strong>move semantics</strong>.
Adding more functionality (e.g., <strong>reference-counting semantics</strong> rather than move semantics) to types by <em>wrapping these in other types</em> typically <em>reduces their run-time performance</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[LIFETIME_DANGLING]]</p>
<p>[[LIFETIME_ELISION]]</p>
<p>[[LIFETIME_STATIC]]</p>
<p>[[LIFETIME_GENERIC]]</p>
<hr />
<h1 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h1>
<blockquote>
<p><em>lifetime = timetolive = subset of their scope.</em></p>
</blockquote>
<p>Rust’s lifetime system is a remarkable feature that enforces <strong>memory safety without the need for a garbage collector</strong>. Lifetimes track how long references to data are valid, preventing dangling pointers and memory leaks.
A function’s local variables live until the function returns, while global variables might live for the life of the program.</p>
<p>Make hypotheses about whether or not your experiments will pass the borrow checker before you compile reference in Rust has a lifetime, which is the scope for which that reference is valid. Most of the time, <strong>lifetimes are implicit and inferred</strong>, just like most of the time, types are inferred.</p>
<p>We must annotate types when multiple types are possible. </p>
<p>In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. <strong>The main aim of lifetimes is to prevent dangling references</strong>, which cause a program to reference data other than the data it’s intended to reference.</p>
<p>When we pass concrete references to longest, the concrete lifetime that is substituted for ’a is the part of the scope of x that overlaps with the scope of y. In other words, the generic lifetime ’a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter ’a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow= <strong>memory-safe operations</strong> and disallow operations that would <strong>create dangling pointers or otherwise violate memory safety.</strong></p>
<p>For data allocated on the stack, we can easily reason by looking at the code and figure out whether a variable is alive or not. For heap allocated values, though, this isn’t clear.</p>
<p>The following are the rules that are followed when eliding lifetimes:
If the input lifetime contains only a single reference, the output lifetime is assumed to be the same</p>
<p>For methods involving self and &amp;mut self, the input lifetime is inferred for the  &amp;self parameter</p>
<p>where we have to specify lifetimes when Rust cannot figure them out for us:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Function signatures</li>
<li><input disabled="" type="checkbox" checked=""/>
Structs and struct fields</li>
<li><input disabled="" type="checkbox" checked=""/>
impl blocks</li>
</ul>
<hr />
<p>Make hypotheses about whether or not your experiments will pass the borrow checker before you compile reference in Rust has a lifetime, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways.</p>
<p>All references in Rust have a lifetime, even if they are not explicitly annotated. The compiler is capable of implicitly assigning lifetimes. </p>
<p>A value’s lifetime is the period when accessing that value is valid behavior. A function’s local variables live until the function returns, while global variables might live for the life of the program.</p>
<p>the notion of ownership is rather limited. An owner cleans up when its values’ lifetimes end.</p>
<p>&lt;’a, ’bdeclares two lifetime variables, ’a and ’b, within the scope of j: &amp;’b i32 binds the lifetime variable ’b to the lifetime of j. The syntax reads as “parameter j is a reference to an i32 with lifetime b.”</p>
<p>All values bound to a given lifetime must live as long as the last access to any value bound to that lifetime.
No lifetime annotations are required when calling a function.</p>
<p>’a in generic func means: function will live at least as long as lifetime ’a
e.g. Note that the longest function doesn’t need to know exactly how long x and y will live, only that some scope can be substituted for ’a that will satisfy this signature.</p>
<ul>
<li>Lifetime annotations don’t change how long any of the references live. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter.</li>
<li>Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</li>
<li>The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</li>
<li>Lifetimes on function or method parameters are called input lifetimes, and lifetimes on return values are called output lifetimes.</li>
</ul>
<p>&lt;’a, ’bdeclares two lifetime variables, ’a and ’b, within the scope of
j: &amp;’b i32 binds the lifetime variable ’b to the lifetime of j. The syntax reads as “parameter j is a reference to an i32 with lifetime b.”</p>
<p>Although every parameter has a lifetime, these checks are typically invisible as the compiler can infer most lifetimes by itself</p>
<p>All values bound to a given lifetime must live as long as the last access to any value bound to that lifetime.
No lifetime annotations are required when calling a function.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn longest_common_prefix&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    let min_length = std::cmp::min(x.len(), y.len());
    let bytes_x = x.as_bytes();
    let bytes_y = y.as_bytes();
    for i in 0..min_length {
        if bytes_x[i] != bytes_y[i] {
        return &amp;x[..i];
        }
    }
        &amp;x[..min_length]
}

fn main() {
    let string1 = &quot;abc&quot;;
    let result;
    {
    let string2 = &quot;abdef&quot;;
    result = longest_common_prefix(string1, string2);
    }
    println!(&quot;The longest common prefix is: {}&quot;, result);
}
// $ rustc lifetimes.rs &amp;&amp; ./lifetimes
// Output: The longest common prefix is: ab
</code></pre></pre>
<p>If we remove lifetimes we’ll be encounter an error:</p>
<p><code>doesn't have a size known at compile-time</code>
<code>help: function arguments must have a statically known size, borrowed types always have a known size</code></p>
<hr />
<p>When we pass concrete references to longest, the concrete lifetime that is substituted for ’a is the part of the scope of x that overlaps with the scope of y. In other words, the generic lifetime ’a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter ’a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.</p>
<p>Using two lifetime parameters (a and b) indicates that the lifetimes of i and j are decoupled.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn add_with_lifetimes&lt;'a, 'b&gt;(i: &amp;'a i32, j: &amp;'b i32) -i32 {}
<span class="boring">}
</span></code></pre></pre>
<p>lifetime of that usage: 
the LOC(‘existence time’ or Line of code) between when a location is first used in a certain way, and when that usage stops.</p>
<p>lifetime of that value:
the LOC (or actual time) between when a value is created, and when that value is dropped.</p>
<p>might be useful when discussing open file descriptors, but also irrelevant here.</p>
<p><code>let r: &amp;'c S = &amp;c;</code></p>
<p>the ’c part, like a type, also guards what is allowed into r.</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</p>
<h2 id="lifetime-of-that-usage"><a class="header" href="#lifetime-of-that-usage">lifetime of that usage</a></h2>
<p>the #LOC (‘existence time’ or Line of code) between when a location is 
first used in a certain way, and when that usage stops.</p>
<h2 id="lifetime-of-that-value"><a class="header" href="#lifetime-of-that-value">lifetime of that value</a></h2>
<p>the LOC (or actual time) between when 
a value is created, and when that value is dropped.
might be useful when discussing open file descriptors.</p>
<h2 id="drop"><a class="header" href="#drop">Drop</a></h2>
<p>When values go out of scope or their lifetimes end for some other reason, their <strong>destructors</strong> are called. A destructor is a function that removes traces of the value from the program by deleting references and freeing memory. You won’t find a call to any destructors in most Rust code. The compiler injects that code itself as part of the process of tracking every value’s lifetime.</p>
<p>To provide a <strong>custom destructor</strong> for a type, we implement Drop. This typically is needed in cases where we have used unsafe blocks to allocate memory. Drop has one method, <strong>drop</strong>(&amp;mut self), that you can use to conduct any necessary wind-up activities.</p>
<p>Unfortunately, it’s not straightforward to disable the automatic drop functionality. Disabling drop isn’t usually necessary; the whole point of the Drop trait is that it’s taken care of automatically. Occasionally, however, you might want to clean up a value early. 
Rust doesn’t let you call the Drop trait’s drop method manually; instead you have to call the <strong>std::mem::drop function</strong></p>
<h3 id="let-vs-const"><a class="header" href="#let-vs-const">Let Vs Const</a></h3>
<h4 id="scope"><a class="header" href="#scope">Scope</a></h4>
<p>const variables are declared in global and local scope unlike let variables that are declared only in the local scope.
Mutability
const variable cannot be mutable unlike let which can be made mutable using mut keyword.</p>
<h4 id="data-type"><a class="header" href="#data-type">Data Type</a></h4>
<p>Unlike let variables, it is mandatory to define the data type of const variables.</p>
<h4 id="set-value-at-run-time"><a class="header" href="#set-value-at-run-time">Set Value at Run-time</a></h4>
<p>The value of const variable can only be set before running the program whereas the let variable can store the result at runtime.</p>
<h4 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h4>
<p>Unlike let variables, const variables cannot be shadowed.</p>
<hr />
<p>If variables defined with #let are immutable, then why does Rust include a #const keyword?</p>
<p>The short answer is that data behind let can change. Rust allows types to have an apparently contradictory property of interior mutability.
At the level of the [[COMPILER]], let relates more to #alias ing than immutability.
Aliasing in compiler terminology refers to having multiple references <strong>to the same location in memory at the same time</strong> </p>
<p><strong>Read-only references</strong> (borrows) to variables declared with <strong>let can alias the same data</strong>.</p>
<p><strong>Read-write references</strong> (mutable borrows) are guaranteed to <strong>never alias data.</strong>
Some types such as std:sync::Arc and std:#rc::Rc present an immutable façade, yet change their internal state over time. In the case of those two types, these increment a #reference_count as references to those are made and decrement that count when those references expire.</p>
<h3 id="const-vs-static"><a class="header" href="#const-vs-static">Const Vs Static</a></h3>
<pre><code>const WORDS: &amp;'static str = &quot;hello rust!&quot;;
</code></pre>
<p>Thanks to static lifetime elision, you usually don’t have to explicitly use ’static:</p>
<pre><code>const WORDS: &amp;str = &quot;hello convenience!&quot;;
</code></pre>
<p>const items looks remarkably similar to static items, which introduces some confusion as to which one should be used at which times. To put it simply,  <strong>constants are inlined</strong>  wherever they’re used, making using them identical to simply replacing the name of the const with its value. Static variables, on the other hand, point to <strong>a single location</strong> in memory, which all accesses share. This means that, unlike with constants, they can’t have <strong>destructors</strong>, and act as a single value across the  <strong>entire codebase</strong> .</p>
<hr />
<p>When values go out of scope or their lifetimes end for some other reason, their destructors are called. A destructor is a function that removes traces of the value from the program by deleting references and freeing memory. You won’t find a call to any destructors in most Rust code. The compiler injects that code itself as part of the process of tracking every value’s lifetime.</p>
<p>To provide a custom destructor for a type, we implement Drop. This typically is needed in cases where we have used unsafe blocks to allocate memory. Drop has one method, drop(&amp;mut self), that you can use to conduct any necessary wind-up activities.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p>syntax &lt;’a, ’b&gt; declares two lifetime variables, ’a and ’b, within the scope of
j: &amp;’b i32 binds the lifetime variable ’b to the lifetime of j. The syntax reads as “parameter j is a reference to an i32 with lifetime b.”
Although every parameter has a lifetime, these checks are typically invisible as the compiler can infer most lifetimes by itself.</p>
<hr />
<p>All values bound to a given lifetime must live as long as the last access to any value bound to that lifetime.
No lifetime annotations are required when calling a function.
<code>Example</code>
’a in generic func means: function will live at least as long as lifetime ’a
e.g. Note that the longest function doesn’t need to know exactly how long x and y will live, only that some scope can be substituted for ’a that will satisfy this signature.</p>
<hr />
<p>Using two lifetime parameters (a and b) indicates that the lifetimes of i and j are decoupled.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_with_lifetimes&lt;'a, 'b&gt;(i: &amp;'a i32, j: &amp;'b i32) -i32 {}//working fine without error
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2 id="glossery-2"><a class="header" href="#glossery-2">Glossery</a></h2>
<p><code>'a</code>:	lifetime a,  lifetime=timetolive=subset of their scope, &amp;’a mut i32 // a mutable reference with an explicit lifetime.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[re-lifetime-static]]</p>
<p>[[ria-lifetime-static]]</p>
<p>[[pb-lifetime-static]]</p>
<hr />
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>Lifetime names for struct fields always need to be declared after the impl keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type.[[STRUCT]]</p>
<p>In method signatures inside the impl block, references might be tied to the lifetime of references in the struct’s fields, or they might be independent.
In addition, the lifetime elision rules often make it so that <strong>lifetime annotations aren’t necessary in method signatures</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}

struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>There are two input lifetimes, so Rust applies the first <strong>lifetime elision rule and gives both &amp;self and announcement their own lifetimes. Then, because one of the parameters is &amp;self, the return type gets the lifetime of &amp;self, and all lifetimes have been accounted for.</strong></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> //no_err_func
fn first_word(s: &amp;str) -&gt; &amp;str {}

fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {}

fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {}

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {}
   // **err_func**
fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {}
  // **no_err_method**
fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>The text of this string is <strong>stored directly in the program’s binary</strong>, which is always available. Therefore, the lifetime of all string literals is ’static.</p>
<p>You might see suggestions to use the ’static lifetime in error messages. </p>
<blockquote>
<p>Most of the time, the problem results from attempting to create <em>a dangling reference or a mismatch of the available lifetimes.</em> <strong>In such cases, the solution is fixing those problems, not specifying the ’static lifetime.</strong></p>
</blockquote>
<h2 id="life-time-static"><a class="header" href="#life-time-static">Life Time Static</a></h2>
<blockquote>
<p>Omitting lifetime annotations is formally referred to as lifetime elision</p>
</blockquote>
<blockquote>
<p>The ’static lifetime is somewhat special. It too owes its name to implementation details. Executable programs can contain a section of memory that is <strong>hard-coded</strong> with values. That section is known as static memory because it is <strong>read-only</strong> during execution.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The text of this string is stored directly in the program’s binary, which is always available. Therefore, the lifetime of all string literals is ’static.</p>
</blockquote>
<blockquote>
<p><strong>You might see suggestions to use the ’static lifetime in error messages. But before specifying ’static as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not.</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>Omitting lifetime annotations is formally referred to as lifetime elision</p>
<blockquote>
<p>Unfortunately, it’s not straightforward to disable the automatic drop functionality. Disabling drop isn’t usually necessary; the whole point of the Drop trait is that it’s taken care of automatically. Occasionally, however, you might want to clean up a value early. </p>
</blockquote>
<blockquote>
<p>Rust doesn’t let you call the Drop trait’s drop method manually; instead you have to call the std::mem::drop function</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[as_ptr]] [[from_utf8]] [[from_raw_parts]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[CONVERT]]
[[ria-for]]
[[rd-str]]</p>
<hr />
<blockquote>
<p>The main aim of lifetimes is to prevent dangling references.
which has an outer scope and an inner scope.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
//    let reference_to_nothing = dangle();
let reference_to_nothing = no_dangle();
}
fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
//primitive types need to &amp;'a or &amp;'static 
  fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);
    s
}
</code></pre></pre>
<blockquote>
<p>no_dangle: This works without any problems. Ownership is moved out, and nothing is deallocated.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lifetime-io"><a class="header" href="#lifetime-io">Lifetime IO</a></h2>
<blockquote>
<p>The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.
Lifetimes on function or method parameters are called <strong>input lifetimes</strong>, and lifetimes on return values are called output lifetimes.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = longest(string1.as_str(), string2);
fun longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {}
<span class="boring">}
</span></code></pre></pre>
<hr />
<blockquote>
<p>Using two lifetime parameters (a and b) indicates that the lifetimes of i and j are decoupled.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_with_lifetimes&lt;'a, 'b&gt;(i: &amp;'a i32, j: &amp;'b i32) -&gt; i32 {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="lifetime-subtyping"><a class="header" href="#lifetime-subtyping">Lifetime Subtyping</a></h2>
<blockquote>
<p>the ’c part, like a type, also guards what is allowed into r.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: &amp;'c S = &amp;c;
<span class="boring">}
</span></code></pre></pre>
<hr />
<blockquote>
<p>This is read as the lifetime ’a outlives ’b or in other words ’b should never live longer than ’a.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, 'b, S, R&gt; Decoder&lt;'a, 'b, S, R&gt;
where 'a: 'b {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="lifetime-bounds"><a class="header" href="#lifetime-bounds">Lifetime Bounds</a></h2>
<blockquote>
<p>Along with the <strong>Send</strong> bound, which says that this thread <strong>can be sent to threads,</strong> we also say that the type must live as long as the ’static lifetime.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Logger&lt;'a&gt;(&amp;'a str, Level);

fn configure_logger&lt;T&gt;(_t: T) where T: Send + 'static {
    // configure the logger here
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<blockquote>
<p><code>tags</code> [[Send]] [[LIFETIME_STATIC]] [[coercion]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[bench]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>[[ria-pointer]]</p>
<p>[[rd-pointer]]</p>
<p>[[SMARTPOINTER]]</p>
<hr />
<blockquote>
<p>What are the differences between references, pointers, and memory addresses?</p>
</blockquote>
<ul>
<li><strong>A memory address</strong>, often shortened to address, is a number that happens to <em>refer to a single byte in memory</em>. Memory addresses are abstractions <em>provided by assembly languages</em>.</li>
</ul>
<blockquote>
<blockquote>
<p>Used <strong>for types</strong> where it’s important to make their <strong>unsafe</strong> nature explicit.</p>
</blockquote>
</blockquote>
<ul>
<li><strong>A pointer</strong>, sometimes expanded to raw pointer, is a memory address that <em>points to a value of some type</em>. Pointers are abstractions provided by <em>higher-level languages</em>.</li>
</ul>
<blockquote>
<blockquote>
<p>Refer to something more <strong>primitive</strong>. This also includes the implication that <strong>we are responsible</strong> for maintaining safety. (There is an implied connotation of being <strong>unsafe</strong>.)</p>
</blockquote>
</blockquote>
<ul>
<li><strong>A reference</strong> <em>is a pointer</em>, or in the case of <em>dynamically sized types</em>, a pointer and an integer with extra guarantees. References are abstractions <em>provided by Rust</em>.
&gt;&gt; References—Signal that the <strong>Rust compiler</strong> will provide its <strong>safety guarantees</strong>.
<ul>
<li>
<blockquote>
<p>References always <strong>refer to valid data</strong>.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>References are correctly aligned to <strong>multiples of usize</strong>.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Rust ensures that <em>a length</em> is kept alongside the <em>internal pointer</em>. That way Rust can ensure that the program never overruns the type’s space in memory.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="reference-vs-pointer"><a class="header" href="#reference-vs-pointer">Reference vs Pointer</a></h2>
<blockquote>
<p>A reference is like a pointer in that it’s an address we can follow to access data stored at that address that is owned by some other variable. </p>
<blockquote>
<p><strong>Unlike a pointer, a reference is</strong> <em>guaranteed to point to a valid value of a particular type.</em></p>
</blockquote>
</blockquote>
<h2 id="asref"><a class="header" href="#asref">AsRef</a></h2>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn data(&amp;self) -&gt; &amp;T {
        self.data.as_ref()
        //&amp;self.data; Equal line above
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="special-pointers"><a class="header" href="#special-pointers">Special pointers</a></h2>
<p>In addition, the following tools can also be handy in certain situations:</p>
<ul>
<li>Deeply interlinked data structures can benefit from <strong>std::rc::Weak and std::arc::Weak</strong> for single and multi-threaded programs, respectively. These allow access to data within an <strong>Rc/Arc without incrementing its reference count</strong>. This can prevent never-ending cycles of pointers.</li>
<li>The <strong>alloc::raw_vec::RawVec</strong> type underlies Vec<T> and <strong>VecDeq<T>.</strong> An expandable, double-ended queue that hasn’t appeared in the book so far, it understands how <strong>to allocate and deallocate memory in a smart way</strong> for any given type. #VecDeque #Vec</li>
<li><strong>The std::cell::UnsafeCell</strong> type sits behind both Cell<T> and RefCell<T>. If you would like to provide interior mutability to your types, its implementation is worth investigating.</li>
</ul>
<hr />
<p><img src="pointers/../rust/assets/images/pointers1.JPG" alt="Pointers in memory" /></p>
<p><img src="pointers/../rust/assets/images/memory.JPG" alt="Memory" /></p>
<h2 id="usize"><a class="header" href="#usize">usize</a></h2>
<blockquote>
<p>[[usize]] is the memory address size for the CPU the code is compiled for. That [[CPU]] is called the compile target.</p>
</blockquote>
<h2 id="raw-pointer"><a class="header" href="#raw-pointer">Raw Pointer</a></h2>
<blockquote>
<p>A [[raw_pointer]] is a memory address without Rust’s standard guarantees. These are inherently <strong>[[unsafe]]</strong>. For example, unlike references (&amp;T), <strong>raw pointers can be null</strong>. If you’ll forgive the syntax, raw pointers are denoted as *const T and *mut T for immutable and mutable raw pointers.</p>
</blockquote>
<ul>
<li>
<p>The difference between a *mut T and a *const T is minimal. These can be freely [[cast]] between one another and tend to be used interchangeably, acting as in-source documentation.</p>
</li>
<li>
<p>Rust references (&amp;mut T and &amp;T) compile down to raw pointers. That means that it’s possible to access the performance of raw pointers <strong>without needing to venture into unsafe blocks.</strong></p>
</li>
<li>
<p>Raw pointers do not own their values. The Rust compiler does not check that the referent data is still valid when these are accessed.</p>
</li>
<li>
<p>Multiple raw pointers to the same data are allowed. Every raw pointer can have write, read-write access to data. This means that there is no time when Rust can guarantee that shared data is valid.</p>
</li>
<li>
<p><strong>It’s unavoidable</strong>. Perhaps some OS call or third-party code requires a raw pointer. Raw pointers are common within C code that provides an external interface. (so because of this we must use raw pointer.)</p>
</li>
<li>
<p><strong>Shared access to something is essential</strong> and runtime performance is paramount. Perhaps multiple components within your application require equal access to some expensive-to-compute variable. If you’re willing to take on the risk of one of those components poisoning every other component with some silly mistake, then raw pointers are an option of last resort. (so because of this we must use raw pointer.)</p>
</li>
<li>
<p><strong>Are allowed to ignore the borrowing rules</strong> by having both immutable and mutable pointers or multiple mutable pointers to the same location</p>
</li>
<li>
<p><strong>Aren’t guaranteed to point to valid memory</strong></p>
</li>
<li>
<p>Are allowed to be <strong>null</strong></p>
</li>
<li>
<p><strong>Don’t implement any automatic cleanup</strong></p>
</li>
</ul>
<p>You can create pointers safely from any integral value. An i32 is not a Vec<String>, but Rust is quite comfortable .ignoring that here.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr = 42 as *const Vec&lt;String&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="raw-pointer-rules"><a class="header" href="#raw-pointer-rules">Raw Pointer Rules</a></h3>
<blockquote>
<p>we can’t cast a &amp;T to a *mut T, as it would violate the borrowing rules that allow only one mutable borrow. so at the first we need as <code> *const u8</code> and then <code> as *mut u8</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b_ptr = &amp;B as *const u8 as *mut u8;
<span class="boring">}
</span></code></pre></pre>
<h2 id="raw-poiner-in-unsafe"><a class="header" href="#raw-poiner-in-unsafe">Raw Poiner In Unsafe</a></h2>
<p>Unsafe Rust has two new types called raw pointers that are similar to references. As with references, raw pointers can be immutable or mutable and are written as *const T and *mut T, respectively. </p>
<blockquote>
<p><strong>The asterisk isn’t the dereference operator</strong>; it’s part of the type name. In the context of raw pointers, immutable means that the pointer can’t be directly assigned to after being dereferenced.</p>
</blockquote>
<blockquote>
<p>unsafe Notice that we don’t include the unsafe keyword in this code. We can create raw pointers in safe code; we just <strong>can’t dereference raw pointers outside an unsafe block</strong>, as you’ll see in a bit.</p>
</blockquote>
<blockquote>
<p>Creating a raw pointer to an arbitrary memory address</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;
let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);    
}

let address = 0x012345usize;
let r = address as *const i32;
unsafe {        
    std::ptr::write(r as *mut usize, 0usize); //Memory overwrite to a address
    println!(&quot;r3 is: {}&quot;, *r);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="data-race"><a class="header" href="#data-race">Data Race</a></h2>
<blockquote>
<p>It’s something that new Rustaceans struggle with, because most languages let you mutate whenever you’d like. The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:</p>
</blockquote>
<blockquote>
<p>Two or more pointers access the same data at the same time.
At least one of the pointers is being used to write to the data.
There’s no mechanism being used to synchronize access to the data.</p>
</blockquote>
<blockquote>
<p><strong>Data races cause</strong> [[undefined_behavior]] and can be difficult to diagnose and fix when you’re trying to track them down at runtime;</p>
</blockquote>
<hr />
<p><img src="pointers/../rust/assets/images/mem-layout1.JPG" alt="Memory-Layout-1" />
<img src="pointers/../rust/assets/images/mem-layout2.JPG" alt="Memory-Layout-2" /></p>
<p><img src="pointers/../rust/assets/images/dynamic-mem.JPG" alt="Dynamic Memory" /></p>
<h2 id="glossery-3"><a class="header" href="#glossery-3">Glossery</a></h2>
<blockquote>
<p><code>Size &amp; Alignment</code>: For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the align_of_val function.The unit tuple (()), which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.the type [u16; 0] has size 0 and alignment 2). The size of a value can be checked with the size_of_val function.</p>
</blockquote>
<blockquote>
<p><code>&amp;mut T</code>: This means that &amp;mut T types do <strong>not implement the Copy</strong> trait.</p>
</blockquote>
<blockquote>
<p><code>&amp;T</code>: A pointer is a <strong>Copy</strong> type, which simply means you can have many immutable references to a value T.</p>
</blockquote>
<blockquote>
<p><code>&amp;</code>:	borrow</p>
</blockquote>
<blockquote>
<p><code>*</code>:	dereference</p>
</blockquote>
<blockquote>
<p>Rust has a feature called automatic referencing and dereferencing.Calling methods is one of the few places in Rust that has this behavior. Rust doesn’t have an equivalent to the -&gt; operator; </p>
<p>Here’s how it works: when you call a method with object.something(), Rust automatically adds in &amp;, &amp;mut, or * so object matches the signature of the method. In other words, the following are the same:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>smart_pointer</code> e.q wrapper type. Rust’s smart pointer types tend to wrap raw pointers and bestow them with added semantics.</p>
</blockquote>
<blockquote>
<p><code>fat pointer Vs thin pointer</code> : The term <strong>fat</strong> pointer refers to <strong>memory layout</strong>. <strong>Thin</strong> pointers, such as <strong>raw pointers</strong>, are <em>a single usize wide</em>. Fat pointers are usually <em>two usize</em> wide,and occasionally more</p>
</blockquote>
<blockquote>
<p><code>tags</code> [[smart_pointer]] [[fat_pointer]] [[data_race]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[BOX]]</p>
<p>[[RC]]</p>
<p>[[REF_CELL]]</p>
<p>[[OPS]]</p>
<p>[[COW]]</p>
<p>[[ARC]]</p>
<p>[[rd-customized-smartpointer-box]]</p>
<hr />
<h2 id="what-are-smart-pointers"><a class="header" href="#what-are-smart-pointers">What are Smart Pointers?</a></h2>
<blockquote>
<p>Smart pointers are abstract data types that act like regular pointers (variables that store memory addresses of values) in programming, coupled with additional features like destructors(drop) and overloaded operators.
They are called smart because they also have extra metadata and code associated with them that gets executed when they are created or destroyed. Being able to automatically free the underlying resource when a smart pointer goes out of scope is one of the major reasons to use smart pointers.
Much of the smartness in smart pointers comes from two traits, called the Drop trait and the Deref trait. Using the dereferencing operator on the memory address returns the location of the value from the pointer points.</p>
</blockquote>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use cases</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Automatically de-allocating data and destructing objects</li>
<li><input disabled="" type="checkbox" checked=""/>
Checking data or variables that exceed their bounds</li>
<li><input disabled="" type="checkbox" checked=""/>
Reducing bugs related to the use of regular pointers</li>
<li><input disabled="" type="checkbox" checked=""/>
Preserving the efficiency of the program after de-allocating data</li>
<li><input disabled="" type="checkbox" checked=""/>
Keeping track of all memory addresses of a program’s data/objects/variables</li>
<li><input disabled="" type="checkbox" checked=""/>
Managing network connections in a program application</li>
</ul>
<h3 id="drop-mechanism"><a class="header" href="#drop-mechanism">Drop Mechanism</a></h3>
<blockquote>
<p>When we instantiate any Drop implementing value (any heap allocated type), the Rust compiler inserts drop method calls after every end of scope, after compilation. So, we don’t need to manually call drop on these instances. This kind of automatic reclamation based on scope is inspired by the RAII principle of C++.</p>
</blockquote>
<h3 id="drerf-mechanism"><a class="header" href="#drerf-mechanism">Drerf Mechanism</a></h3>
<blockquote>
<p>smart pointer types often implement the Deref trait, which allows us to use the * dereferencing operator with these types. While Deref gives you read-only access, there is also DerefMut, which can give you a mutable reference to the underlying type. Deref has the following type signature:
Enabling <em>easy access to the data</em> stored behind the smart pointers. You can use the Deref trait to <em>treat smart pointers as a reference</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Deref coercion is a convenience that Rust performs on arguments to functions and methods. Deref coercion works only on types that implement the Deref trait. </p>
</blockquote>
<blockquote>
<p>Deref coercion converts such a type into a reference to another type. For example, deref coercion can convert &amp;String to &amp;str because String implements the Deref trait such that it returns &amp;str. </p>
</blockquote>
<blockquote>
<p>The number of times that Deref::deref needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>
</blockquote>
<blockquote>
<p>Similar to how you use the Deref trait to override the * operator on immutable references, you can use the DerefMut trait to override the * operator on mutable references.</p>
</blockquote>
<blockquote>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
</blockquote>
<ul>
<li>From &amp;T to &amp;U when T: Deref&lt;Target=U&gt;</li>
<li>From &amp;mut T to &amp;mut U when T: DerefMut&lt;Target=U&gt;</li>
<li>From &amp;mut T to &amp;U when T: Deref&lt;Target=U&gt;</li>
<li>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is not possible</li>
</ul>
<blockquote>
<p>the Drop trait is almost always used when implementing a smart pointer. For example, when a Box<T> is dropped it will deallocate the space on the heap that the box points to.</p>
</blockquote>
<blockquote>
<p><em>Note that we didn’t need to call the+ drop method explicitly.</em></p>
</blockquote>
<blockquote>
<p>State is a trait, we call the as_ref method on the Option because we want a reference to the value inside the Option rather than ownership of the value. 
Because state is an <code>Option&lt;Box&lt;dyn State&gt;&gt;</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>At this point, when we call content on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion will take effect on the &amp; and the Box so the content method will ultimately be called on the type that implements the State trait.</p>
</blockquote>
<blockquote>
<p>If defines a single method called Deref that takes self by reference and returns a immutable reference to the underlying type. This combined with the deref coercion feature of Rust, reduces a lot of code that you have to write. Deref coercion is when a type automatically gets converted from one type of reference to some other reference.</p>
</blockquote>
<h2 id="comparistions-of-smart-pointers"><a class="header" href="#comparistions-of-smart-pointers">Comparistions of Smart pointers</a></h2>
<p><img src="pointers/smartpointer/../../rust/assets/images/Ownership.jpg" alt="Ownership" /></p>
<hr />
<h3 id="pointer-definations--comparision"><a class="header" href="#pointer-definations--comparision">Pointer Definations &amp; Comparision</a></h3>
<blockquote>
<p>Rc<T> enables multiple owners of the same data; whenever somebody takes a new reference, and decrements it when someone releases a reference. When the counter hits zero, the value is dropped.Rc<T> does not allow mutation. To permit that, we need to wrap our wrapper. Rc&lt;RefCell<T>&gt; is a type that can be used to perform interior mutability . An object that has interior mutability presents an immutable façade while internal values are being modified.</p>
</blockquote>
<blockquote>
<p>Rc<T> is not thread-safe. In multithreaded code safety, it’s much better to replace Rc<T> with Arc<T> and Rc&lt;RefCell<T>&gt; with Arc&lt;Mutex<T>&gt;.</p>
</blockquote>
<blockquote>
<p>Box<T> The ownership semantics with Box type depends on the wrapped type. If the underlying type is Copy, the Box instance becomes copy, otherwise it moves by default.allows immutable or mutable borrows checked at compile time; Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable or mutable borrows checked at runtime.</p>
</blockquote>
<blockquote>
<p>Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.</p>
</blockquote>
<blockquote>
<p>Cell<T>: This gives us internal mutability for types that implement the Copy trait. In other words, we gain the possibility to get multiple mutable references to something.</p>
</blockquote>
<blockquote>
<p>RefCell<T>: This gives us internal mutability for types, without requiring the Copy trait. It uses runtime locking for safety. Lets us have many immutable borrows or one mutable borrow at any point in time.Box<T> and RefCell<T> have single owners. For types that implement Copy, the get method retrieves the current interior value. For types that implement Default, the take method replaces the current interior value with Default::default() and returns the replaced value.For all types, the replace method replaces the current interior value and returns the replaced value and the into_inner method consumes the Cell<T> and returns the interior value. Additionally, the set method replaces the interior value, dropping the replaced value.</p>
</blockquote>
<p><img src="pointers/smartpointer/../../rust/assets/images/smart-pointer-1.JPG" alt="Smart-Pointer-1" /></p>
<p><img src="pointers/smartpointer/../../rust/assets/images/smart-pointer-2.JPG" alt="Smart-Pointer-2" /></p>
<p><img src="pointers/smartpointer/../../rust/assets/images/smart-pointer-3.JPG" alt="Smart-Pointer-3" /></p>
<h3 id="comparison-of-inherited-and-interiormutability"><a class="header" href="#comparison-of-inherited-and-interiormutability">Comparison of inherited and interior/mutability</a></h3>
<blockquote>
<p>We say that Cell<T> and RefCell<T> provide ‘interior mutability’, in contrast with typical Rust types that exhibit ‘inherited mutability’ the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.</p>
</blockquote>
<blockquote>
<p>Similar to Rc<T>, RefCell<T> is only for use in [[single_threaded]] scenarios.The Cell and RefCell types are not thread safe. This simply means that Rust won’t allow you to share these types in multiple threads.</p>
</blockquote>
<blockquote>
<p>There’s also Mutex<T>, which offers interior mutability that’s safe to use across threads [[multi_tread]] scenarios.</p>
</blockquote>
<blockquote>
<p>Neither Cell<T> nor RefCell<T> are thread safe (they do not implement #Sync)
Standard library has other types that provide interior mutability:</p>
</blockquote>
<blockquote>
<blockquote>
<p>Such as Cell<T>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>.</p>
</blockquote>
</blockquote>
<h2 id="special-types"><a class="header" href="#special-types">Special Types</a></h2>
<p><a href="https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#special-types-and-traits">Special Traits&amp;Types</a></p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li>[[Arc]] stands for #atomic_reference_counter.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-smartpointer-rc]]</p>
<p>[[rd-smartpointer-rc]]</p>
<p>[[LINKEDLIST]]</p>
<hr />
<blockquote>
<p>[[SemiAutomatic]]</p>
</blockquote>
<blockquote>
<p>To enable multiple ownership, Rust has a type called Rc<T>, which is an abbreviation for reference counting. The Rc<T> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
</blockquote>
<blockquote>
<p>Imagine Rc<T> as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</p>
</blockquote>
<blockquote>
<p>We use the <strong>Rc<T></strong> type when we want to allocate some data on the <strong>heap</strong> for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>
</blockquote>
<blockquote>
<p>Rc increases by 1 whenever an Rc is <strong>cloned</strong>, and decreases by 1 whenever one cloned Rc is dropped out of the scope</p>
</blockquote>
<blockquote>
<blockquote>
<p><strong>The definition of Cons to hold references instead, but then we would have to specify lifetime parameters.</strong>
By specifying [[lifetime]] parameters, we would be specifying that every element in the list will live at least as long as the entire list.</p>
</blockquote>
</blockquote>
<blockquote>
<p>multiple [[mutable_borrow]] s to the same place can cause [[data_race]] s and inconsistencies.</p>
</blockquote>
<blockquote>
<p>But being able to mutate data is very useful! In the next section, mutability pattern and the RefCell<T> type that you can use in conjunction with an Rc<T> to work with this [[interior_immutability]] restriction</p>
</blockquote>
<blockquote>
<p>Using Rc<T> came with the <strong>risk of creating reference cycles, where two Rc<T></strong> values refer to each other, causing [[memory_leaks]].</p>
</blockquote>
<h1 id="interior-mutability-is-a-design-pattern"><a class="header" href="#interior-mutability-is-a-design-pattern">Interior mutability is a design pattern</a></h1>
<blockquote>
<p>That allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. </p>
</blockquote>
<blockquote>
<p>RefCell<T> type that follows the interior mutability pattern.</p>
</blockquote>
<blockquote>
<p>Unlike Rc<T>, the <strong>RefCell<T> type represents single ownership</strong> over the data it holds. So, what makes RefCell<T> different from a type like Box<T>? Recall the borrowing rules.</p>
</blockquote>
<blockquote>
<p>Similar to <strong>Rc<T>, RefCell<T> is only for use in single-threaded</strong> scenarios and will give you a compile-time error if you try using it in a multithreaded context.</p>
</blockquote>
<blockquote>
<p>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.References must always be valid.</p>
</blockquote>
<blockquote>
<p><strong>RefCell<T> uses Rust’s lifetimes to implement ‘dynamic borrowing’</strong>, a process whereby one can claim temporary, exclusive, <strong>mutable access to the inner value.</strong>
Because RefCell<T> borrows are dynamic it is possible to attempt to <strong>borrow a value that is already mutably borrowed; when this happens it results in thread panic.</strong></p>
</blockquote>
<h2 id="refcell-and-cell"><a class="header" href="#refcell-and-cell">Refcell and Cell</a></h2>
<p>With [[interior_mutability]], you may want to provide an argument to a method that takes immutable values, yet you need to retain mutability. If you’re willing to pay the runtime performance cost, it’s possible to fake immutability. </p>
<blockquote>
<p>If the method requires an owned <strong>value, wrap</strong> the argument in <em>Cell<T></em> . <strong>References can also be wrapped</strong> in <em>RefCell<T></em>. </p>
</blockquote>
<h2 id="rc"><a class="header" href="#rc">RC</a></h2>
<blockquote>
<p>Rc is not threadsafe in spite of [[Arc]], RC is common when using the reference counted types Rc<T> and Arc<T>, which only accept immutable arguments, to also wrap those in Cell<T> or RefCell<T>. The resulting type might look like Rc&lt;RefCell<T>&gt;. </p>
</blockquote>
<blockquote>
<p>This means that you pay the <strong>runtime cost twice (by using additional wrapper as Rc on Cell or RefCell wrapers)</strong> but with significantly more flexibility.</p>
</blockquote>
<blockquote>
<p>With shared ownership, some objects, such as a network connection or, perhaps, access to some OS service, are difficult to mould into the pattern of having a single place with read-write access at any given time. Code might be simplified if two parts of the program can <strong>share access to that single resource</strong>. Rust allows you to do this, but again, at the expense of a runtime cost.</p>
</blockquote>
<blockquote>
<p>Rc internally keeps two kinds of references: strong <strong>(Rc<T>)</strong> and weak <strong>(Weak<T>)</strong>. Both keep a count of how many references of each type have been handed out.</p>
</blockquote>
<h2 id="rc-vs-arc-code-like-pro"><a class="header" href="#rc-vs-arc-code-like-pro">Rc VS Arc [[code-like-pro]]</a></h2>
<blockquote>
<p>Rc is not threadsafe in spite of [[Arc]], and Unlike [Rc<T>], Arc<T> uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that <strong>atomic operations are more expensive</strong> than ordinary memory accesses. </p>
<p>If you are not sharing reference-counted allocations between threads, consider using <strong>[Rc<T>] for lower overhead</strong>.</p>
<p>[Arc<T>] is a safe default, because the compiler will catch any attempt to send an [Rc<T>] between threads. However, a library might choose Arc<T> in order to give library consumers more flexibility.</p>
</blockquote>
<h2 id="rc-immutate"><a class="header" href="#rc-immutate">RC-Immutate</a></h2>
<blockquote>
<p>If implementing Clone would be prohibitively expensive, <strong>Rc<T></strong> can be a handy alternative. This allows two places to <strong>“share” ownership.</strong></p>
</blockquote>
<blockquote>
<p>Some types overload the [[Clone]] trait. This is done to provide something similar to, yet different from, creating duplicates. For example, std::rc::<strong>Rc<T> uses Clone to create additional references when .clone() is called.</strong></p>
</blockquote>
<blockquote>
<p>We could have called a.clone() rather than Rc::clone(&amp;a), but Rust’s convention is to use Rc::clone in this case. The implementation of <strong>Rc::clone doesn’t make a deep copy</strong> of all the data like most types’ implementations of clone do.The call to Rc::clone only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time.</p>
</blockquote>
<blockquote>
<p><strong>Rc is used to track valid references.</strong> As each reference is created, an internal counter increases by one. When a reference is dropped, the count decreases by one. When the count hits zero, T is also dropped. <strong>Wrapping T</strong> involves a calling Rc::new().</p>
</blockquote>
<h2 id="rc-mutate"><a class="header" href="#rc-mutate">RC Mutate</a></h2>
<blockquote>
<p>Rc<T> does not allow mutation. To permit that, we need to wrap our wrapper.</p>
</blockquote>
<blockquote>
<p>Rc&lt;RefCell<T>&gt; is a type that can be used to perform <strong>interior mutability</strong></p>
</blockquote>
<h2 id="reference-counting-semantics-vs-move-semantic"><a class="header" href="#reference-counting-semantics-vs-move-semantic">Reference counting semantics Vs Move semantic</a></h2>
<blockquote>
<p>Adding more functionality (e.g., reference-counting semantics rather than move semantics) to types by wrapping these in other types typically reduces their runtime performance.
If implementing Clone would be prohibitively expensive, Rc<T> can be a handy alternative. This allows two places to “share” ownership.</p>
<blockquote>
<p><strong>Rc<T> is not thread-safe. In multithreaded code</strong>, it’s much better to replace Rc<T> with Arc<T> and Rc&lt;RefCell<T>&gt; with Arc&lt;Mutex<T>&gt;. [[Arc]] stands for #atomic reference counter.</p>
</blockquote>
</blockquote>
<h2 id="week"><a class="header" href="#week">Week</a></h2>
<p>Week is a version of Rc that <strong>holds a non-owning reference</strong> to the managed allocation. The allocation is accessed by calling upgrade on the Weak pointer, which returns an Option&lt;Rc<T>&gt;.</p>
<p>Since a Weak reference does not count towards ownership, it will not prevent the value stored in the allocation from being dropped, and Weak itself makes no guarantees about the value still being present. Thus it may return None when upgraded. Note however that a Weak reference does prevent the allocation itself (the backing store) from being deallocated.</p>
<p>A Weak pointer is useful for keeping a temporary reference to the allocation managed by Rc without preventing its inner value from being dropped. It is also <strong>used to prevent circular references between Rc pointers</strong>, since mutual owning references would never allow either Rc to be dropped. For example, a tree could have <strong>strong Rc pointers from parent nodes to children, and Weak pointers from children back to their parents.</strong></p>
<p>The typical way to obtain <strong>a Weak pointer is to call Rc::downgrade</strong></p>
<hr />
<blockquote>
<p><code>tags</code> [[pattern_design_interior]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-smartpointer-box]]</p>
<p>[[rd-customized-smartpointer-box]]</p>
<hr />
<blockquote>
<p>The Box type can be used in the following situations:</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<p>It can be used to create <strong>recursive type</strong> definitions. </p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>When you need to <strong>store types as trait objects</strong>.</p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>When you need to <strong>store functions in a collection</strong>.</p>
</li>
</ul>
<blockquote>
<p>cons=recursive type</p>
<p>We now know that any List value will take up the size of an i32 plus the size of a box’s pointer data. By using a box, <strong>we’ve broken the infinite</strong>, recursive chain, so the <strong>compiler can figure out the size it</strong> needs to <em>store a List value</em>.
Cons+Box :A List that is not infinitely sized because Cons holds a Box Cons : A List that is infinitely sized because Cons is just a name and it is replacable with anyname.</p>
<blockquote>
<p>Boxes allow you to store data on the heap rather than the stack.</p>
</blockquote>
</blockquote>
<blockquote>
<p>What remains on the stack is the pointer to the heap also don’t have any performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need.
&gt;&gt;The Box<T> type is a [[smart_pointer]] because it implements the #Deref trait, </p>
<p><strong>which allows Box<T> values to be treated like references</strong>. When a Box<T> value goes out of scope, the [[heap]] data that the box is pointing to is cleaned up as well because of the [[Drop]] [[trait]] implementation.</p>
</blockquote>
<blockquote>
<p>You’ll use them most often in these situations:</p>
</blockquote>
<blockquote>
<p><strong>When you have a type whose size can’t be known at compile time</strong> and you want to use a value of that type in a context that requires an exact size <strong>When you have a large amount of data</strong> and you want to transfer ownership but ensure the data won’t be copied when you do so When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type.</p>
</blockquote>
<blockquote>
<p>At [[compile_time]] , Rust needs to know how much space a type takes up. One type <strong>whose size can’t be known at compile time is a recursive type</strong>, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn’t know how much space a value of a recursive type needs.</p>
<p>However, <strong>boxes have a known size</strong>, so by inserting a box in a recursive type definition, you can have recursive types.</p>
</blockquote>
<blockquote>
<p><strong>Box is very useful for returning traits</strong>. You also saw that we can <strong>use impl Trait to return other traits, or closures</strong>. Box can be used in a similar way. </p>
</blockquote>
<blockquote>
<p>You can use a <strong>Box because otherwise the compiler won’t know the size of the value</strong>. </p>
<blockquote>
<p><strong>[[dyn]]</strong> is a word that shows you that you are talking about a <strong>trait</strong>, not a struct or anything else.</p>
</blockquote>
</blockquote>
<h2 id="recursive"><a class="header" href="#recursive">Recursive</a></h2>
<blockquote>
<p>At compile time, Rust needs to know how much space a type takes up. One type whose size can’t be known at compile time is a recursive type, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn’t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</p>
</blockquote>
<blockquote>
<p>Let’s explore the cons list, which is a data type common in <strong>functional programming languages, as an example of a recursive type.</strong> The cons list type we’ll define is straightforward except for the recursion; therefore, the concepts in the example we’ll work with will be useful any time you get into more complex situations involving recursive types.
A cons list is a data structure.</p>
</blockquote>
<blockquote>
<p>cons function (short for “construct function”) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.
cons x onto y” informally means to construct a new container instance by putting the element x at the start of this new container, followed by the container y.</p>
<p>Each item in a cons list contains two elements: the value of the current item and the next item. The last item in the list contains only a value called Nil without a next item. A cons list is produced by recursively calling the cons function. The canonical name to denote the base case of the recursion is Nil.
The canonical name to denote the base case of the recursion is Nil. Note that this is not the same as the “null” or “nil” concept.</p>
</blockquote>
<blockquote>
<p>Although functional programming languages use cons lists frequently, the cons list isn’t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, Vec<T> is a better choice to use. Other, more complex recursive data types are useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.
Nil variant stores no values, so it needs less space than the Cons variant.</p>
</blockquote>
<h2 id="drop-box"><a class="header" href="#drop-box">Drop Box</a></h2>
<blockquote>
<p>All of the programmer-facing pointer types like Box<T> are built from more primitive types that live deeper within Rust, often in its core or alloc modules.</p>
</blockquote>
<blockquote>
<p>std::mem::drop brings the function #drop () into local scope. drop() deletes objects before their scope ends.
Types that implement Drop have a drop() method, but explicitly calling it is illegal within user code. std::mem::drop is an escape hatch from that rule.</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[recursive]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr-ref-cell]]</p>
<p>[[rd-ref-cell]]</p>
<p>[[pp-ref-cell]]</p>
<hr />
<h2 id="interior-mutability"><a class="header" href="#interior-mutability">Interior Mutability</a></h2>
<blockquote>
<p>*o.into_mut() += 2;// About ~ like borrow_mut in RC type both of them called interior mutability pattern(Mutably the wrap value).</p>
</blockquote>
<blockquote>
<p>Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. </p>
</blockquote>
<blockquote>
<p>RefCell<T> type that follows the interior mutability pattern.</p>
</blockquote>
<blockquote>
<p>The RefCell<T> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</p>
</blockquote>
<hr />
<blockquote>
<p>The RefCell type provides us with the following two borrowing methods:</p>
</blockquote>
<ul>
<li>The borrow method takes a new immutable reference</li>
<li>The borrow_mut method takes a new mutable reference</li>
</ul>
<hr />
<blockquote>
<p>The mutability of a binding is not fine-grained; a value is either immutable or mutable, and that includes all of its fields if it’s a struct or an enum. Cell and RefCell can turn an immutable thing into something that’s mutable, <strong>allowing us to define parts of an immutable struct as mutable</strong>.</p>
</blockquote>
<blockquote>
<p>Whenever we’re using RefCell borrows, it’s a good practice to think carefully that we’re using it in a safe way, since making mistakes there may lead to runtime panics. In this implementation, however, it’s easy to see that we have just the single borrow, and that the closing block immediately discards it.</p>
</blockquote>
<blockquote>
<p>Apart from shared ownership, we can also get <strong>shared mutability at runtime</strong> with Rust’s concept of interior mutability, which are modeled by special wrapper smart pointer types.</p>
</blockquote>
<blockquote>
<p>We need to understand the concept of interior mutability and inherited mutability:</p>
</blockquote>
<blockquote>
<p>Inherited mutability: This is the <strong>default</strong> mutability you get when you take a <strong>&amp;mut</strong> reference to some struct. This also implies that you can modify any of the fields of the struct.</p>
</blockquote>
<blockquote>
<p>Interior mutability: In this kind of mutability, even if you have a <strong>&amp;SomeStruct reference</strong> to some type, you can modify its fields if the fields have the type as <strong>Cell<T> or RefCell<T></strong>. to ensure that no two mutable borrows are present at runtime.</p>
</blockquote>
<h2 id="cell"><a class="header" href="#cell">Cell</a></h2>
<p>only added cost is that you have to write a bit more. The additional <strong>runtime cost is zero</strong>, though, and the references to the mutable things remain immutable.</p>
<p>The Cell<T> type is a smart pointer type that <strong>enables mutability for values, even behind an immutable reference</strong>. It provides this capability with very minimal overhead and has a minimal API:</p>
<blockquote>
<p>Cell::new method allows you to create new instances of the Cell type by passing it any type T.</p>
</blockquote>
<blockquote>
<p>Get: The get method allows you to copy of the value in the cell. This method is only available if the wrapped type T is Copy.</p>
</blockquote>
<blockquote>
<p>Set: Allows you to modify the inner value, even behind a immutable reference.</p>
</blockquote>
<h2 id="refcell"><a class="header" href="#refcell">RefCell</a></h2>
<blockquote>
<p>If you need Cell-like features for non-Copy types, there is the RefCell type. It uses a read/write pattern similar to how borrowing works, but moves the checks to runtime, which is convenient but <strong>not zero-cost</strong>.</p>
</blockquote>
<h2 id="refcell-vs-cell"><a class="header" href="#refcell-vs-cell">RefCell vs Cell</a></h2>
<blockquote>
<p>RefCell hands out references to the value, instead of returning things by value as is the case with the Cell type.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[er-smartpointer-ops]]</p>
<p>[[rd-smartpointer-ops]]</p>
<hr />
<h2 id="treating-smart-pointers-like-regular-references-with-the-deref-trait"><a class="header" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait">Treating Smart Pointers Like Regular References with the Deref Trait</a></h2>
<blockquote>
<p>By implementing Deref in such a way that a smart pointer can be treated like a regular reference.</p>
</blockquote>
<blockquote>
<p>Note: there’s one big difference between the MyBox<T> type we’re about to build and the real Box<T>: our version will not store its data on the heap. We are focusing this example on Deref, so where the data is actually stored is less important than the pointer-like behavior.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail.no_run edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y); //error[E0277]: can't compare `{integer}` with `&amp;{integer}`
}
</code></pre></pre>
<blockquote>
<p>Comparing a number and a reference to a number isn’t allowed because they’re different types. We must use the dereference operator to follow the reference to the value it’s pointing to:</p>
</blockquote>
<blockquote>
<p>we set y to be an instance of <strong>a Box<T> pointing to a copied value of x rather than a reference pointing to the value of x</strong>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<blockquote>
<p><code>Attention to example folder/a customize box with Deref feature</code>’</p>
</blockquote>
<blockquote>
<p>This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</p>
</blockquote>
<blockquote>
<p>When the Deref trait is defined for the types involved, Rust will analyze the types and use Deref::deref as many times as necessary to get a reference to match the parameter’s type. The number of times that Deref::deref needs to be inserted <em>is resolved at compile time</em>, so there is <strong>no runtime penalty for taking advantage of deref coercion!</strong></p>
</blockquote>
<h2 id="how-deref-coercion-interacts-with-mutability"><a class="header" href="#how-deref-coercion-interacts-with-mutability">How Deref Coercion Interacts with Mutability</a></h2>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ul>
<li>From &amp;T to &amp;U when T: Deref&lt;Target=U&gt;</li>
<li>From &amp;mut T to &amp;mut U when T: DerefMut&lt;Target=U&gt;</li>
<li>From &amp;mut T to &amp;U when T: Deref&lt;Target=U&gt;</li>
</ul>
<p>The first two cases are the same as each other except that the second implements mutability. The first case states that if you have a &amp;T, and T implements Deref to some type U, you can get a &amp;U transparently. The second case states that the same deref coercion happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is not possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don’t guarantee that. Therefore, <strong>Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.</strong></p>
<hr />
<blockquote>
<p><code>tags</code> [[Deref]] [[ops]]  [[Box]] #deref_coercion_feature</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[rd-smartpointer-cow]]</p>
<p>[[clp-smartpointer-cow]]</p>
<hr />
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use-Cases</a></h2>
<blockquote>
<p>[[Cow]] is a [[smart_pointer]] type that reads from its pointer location <strong>without needing to copy</strong>(like Box,  stands for copy on write) it first.</p>
</blockquote>
<blockquote>
<p>Why write something down when you only need to read it? Perhaps you only want <strong>to make modifications</strong>. This is the role of Cow (copy on write).</p>
</blockquote>
<blockquote>
<p>Cow smart pointer type is handy when an external source <strong>provides a buffer</strong>. <em>Avoiding copies increases runtime performance</em>.</p>
</blockquote>
<blockquote>
<p>The type Cow is a smart pointer providing <em>clone-on-write functionality</em>: it can enclose and provide <strong>immutable access to borrowed data</strong>, and <strong>clone the data lazily when mutation or ownership is required</strong>. The type is designed to <strong>work with general borrowed data</strong> via the Borrow trait. Cow implements Deref, which means that you can call non-mutating methods directly on the data it encloses. If mutation is desired, to_mut will obtain a mutable reference to an owned value, cloning if necessary. If you need reference-counting pointers, note that Rc::make_mut and Arc::make_mut can provide clone-on-write functionality as well.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::Cow;
pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + 'a + ?Sized,  {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>This type is suitable for cases where one needs to <strong>avoid allocations where it’s not needed</strong>. A real world example is the JSON parser crate called serde_json.</p>
</blockquote>
<blockquote>
<p>First, we have the two variants:</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Borrowed that represents the borrowed version of some type B. This B has to implement the ToOwned trait.</li>
<li><input disabled="" type="checkbox" checked=""/>
There is also owned variant which contains the owned version of the type.</li>
</ul>
<h2 id="sample-use-case"><a class="header" href="#sample-use-case">Sample Use-case</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::CStr;
use std::os::raw::c_char;
static B: [u8; 10] = [99, 97, 114, 114, 121, 116, 111, 119, 101, 108];
static C: [u8; 11] = [116, 104, 97, 110, 107, 115, 102, 105, 115, 104, 0];
 let c: Cow&lt;str&gt;;
 unsafe {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>[[CStr]] is a C-like string type that allows Rust to read in zero-terminated strings.</p>
</blockquote>
<blockquote>
<p>[[c_char]] , a type alias for Rust’s i8 type, presents the possibility of a platform-specific nuances.</p>
</blockquote>
<blockquote>
<p><strong>String is a [[smart_pointer]]</strong> type that holds a pointer to a backing array and a field to store its size</p>
</blockquote>
<blockquote>
<p>[[Cow]] accepts a type parameter for the data it points to; str is the type returned by CStr. #to_string_lossy (), so it is appropriate here.</p>
<p>std:: [[ffi]] is the <strong>f</strong>oreign <strong>f</strong>unction <strong>i</strong>nterface module from Rust’s standard library. </p>
<p>use std::os::raw::c_char; is not strictly needed, but it does make the code’s intent clear.</p>
<p>C does not define the width of its char type in its standard, although it’s one byte wide in practice. Retrieving the type alias c_char from the std::os:raw module allows for differences.</p>
</blockquote>
<blockquote>
<p>References cannot be [[cast]] directly to *mut T, the type required by String::from_raw_parts(). But [[star_const]] T can be cast to *mut T, leading to this double cast syntax</p>
</blockquote>
<p><code>let b_ptr = &amp;B as *const u8 as *mut u8;</code></p>
<blockquote>
<p>String:: #from_raw_parts () accepts a pointer (*mut T) to an array of bytes, a size, and a [[capacity]] parameter</p>
</blockquote>
<p><code>b = String::from_raw_parts(b_ptr, 10, 10);</code></p>
<blockquote>
<p>Converts a *const u8 to a *const i8, aliased to c_char. The conversion to i8 works because we remain under 128, following the #ASCII standard.</p>
</blockquote>
<p><code>let c_ptr = &amp;C as *const u8 as *const c_char;</code></p>
<blockquote>
<p>Conceptually, CStr:: #from_ptr () takes responsibility for reading the pointer until it reaches 0; then it generates Cow<str> from the result</p>
</blockquote>
<p><code>c = CStr::from_ptr(c_ptr).to_string_lossy();</code></p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>println!(&quot;a: {}, b: {}, c: {}&quot;, a, b, c);

<span class="boring">}
</span></code></pre></pre>
<p>In Rust programming, the “clone-on-write” functionality refers to a mechanism provided by the <code>Cow</code> (short for “clone on write”) type, which is part of the standard library under <code>std::borrow</code>. The <code>Cow</code> type is a smart pointer that offers efficient handling of data that may be borrowed or owned. It provides immutable access to borrowed data and clones the data lazily when mutation or ownership is required. This approach optimizes performance by avoiding unnecessary cloning until it’s absolutely needed, such as when the data needs to be modified or owned.</p>
<h3 id="how-cow-works"><a class="header" href="#how-cow-works">How <code>Cow</code> Works</a></h3>
<p>The <code>Cow</code> type is defined as an enumeration with two variants:</p>
<ul>
<li><code>Borrowed(&amp;'a B)</code>: Represents borrowed data, where <code>'a</code> is the lifetime of the reference to the data, and <code>B</code> is the type of the data.</li>
<li><code>Owned(&lt;B as ToOwned&gt;::Owned)</code>: Represents owned data, where <code>&lt;B as ToOwned&gt;::Owned</code> is the owned version of the data type <code>B</code>.</li>
</ul>
<p>The <code>Cow</code> type is generic over the data type <code>B</code>, which must implement the <code>ToOwned</code> trait. This trait is used to convert a borrowed instance of <code>B</code> into an owned instance. The <code>Cow</code> type itself implements <code>Deref</code>, allowing you to treat instances of <code>Cow</code> as references to the underlying data, unless you explicitly request a mutable reference using the <code>to_mut()</code> method, which triggers cloning if necessary.</p>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<p>Consider a scenario where you have a function that processes a string, possibly modifying it based on certain conditions. Using <code>Cow</code> ensures that the string is only cloned when modification is actually required, saving resources:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::Cow;

fn process_string(s: &amp;str, condition: bool) -&gt; Cow&lt;'_, str&gt; {
    if condition {
        Cow::from(s.replace(&quot;old&quot;, &quot;new&quot;)) // Clones the string if it's replaced
    } else {
        Cow::from(s) // Uses the borrowed reference if no modification is needed
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, <code>process_string</code> takes a string slice and a boolean flag indicating whether the string should be modified. If the condition is true, it replaces “old” with “new” in the string. However, the replacement operation (<code>replace</code>) returns a new <code>String</code>, necessitating a clone. By wrapping the result in <code>Cow</code>, the function avoids cloning the string unless the replacement is actually performed.</p>
<h3 id="benefits-of-cow"><a class="header" href="#benefits-of-cow">Benefits of <code>Cow</code></a></h3>
<ul>
<li><strong>Efficiency</strong>: <code>Cow</code> minimizes unnecessary cloning, improving performance by delaying cloning until it’s absolutely necessary.</li>
<li><strong>Flexibility</strong>: It supports both borrowed and owned data, making it versatile for various use cases.</li>
<li><strong>Safety</strong>: Leveraging Rust’s borrow checker, <code>Cow</code> helps ensure safety by preventing data races and ensuring that modifications are made on owned data.</li>
</ul>
<p>In summary, the “clone-on-write” functionality in Rust, facilitated by the <code>Cow</code> type, provides a powerful tool for efficiently managing data that may be shared or owned, optimizing resource usage and performance in Rust applications.</p>
<hr />
<blockquote>
<p><code>tags</code> [[Box]] [[LinkedList]] [[Cow]] [[from_raw_parts]] [[from_ptr]] [[CStr]] [[raw_pointer]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc">ARC</a></h1>
<ul>
<li><a href="thread/sync/arc/./ultimate/ultimate_arc.html">Ultimate Arc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>[[pp-command]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[VECTOR]]</p>
<p>[[SLICE]]</p>
<h2 id="hashmap"><a class="header" href="#hashmap">[[HASHMAP]]</a></h2>
<blockquote>
<p>reserve more space to avoid frequent reallocations.</p>
</blockquote>
<ul>
<li>String  with_capacity()</li>
<li>Vec  reserve()</li>
</ul>
<h2 id="slice-vs-char-vs-vec"><a class="header" href="#slice-vs-char-vs-vec">Slice vs Char Vs Vec</a></h2>
<blockquote>
<p>•char—A single character encoded as 4 bytes. The internal representation of char is equivalent to UCS-4/UTF-32. This differs from &amp;str and String, which encodes single characters as UTF-8. Conversion does impose a penalty, but it means that char values are of fixed-width and are, therefore, easier for the compiler to reason about. Characters encoded as UTF-8 can span 1 to 4 bytes.</p>
</blockquote>
<blockquote>
<p>•[u8]—A slice of raw bytes, usually found when dealing with streams of binary data.
It’s easy to get confused with slices [T], which do not have a compile-time length.
Slices are dynamically sized array-like objects. The term dynamically sized means that their size is not known at compile time. Yet, like arrays, these don’t expand or contract. The use of the word dynamic in dynamically sized is closer in meaning to dynamic typing rather than movement. The lack of compile-time knowledge explains the distinction in the type signature between an array ([T; n ]) and a slice ([T]).</p>
</blockquote>
<blockquote>
<p>Slices are important because it’s easier to implement traits for slices than arrays. Traits are how Rust programmers add methods to objects. As [T; 1], [T; 2], …, [T; n ] are all different types, implementing traits for arrays can become unwieldy. Creating a slice from an array is easy and cheap because it doesn’t need to be tied to any specific size.</p>
</blockquote>
<blockquote>
<p>Another important use for slices is their ability to act as a view on arrays (and other slices). The term view here is taken from database technology and means that slices can gain fast, read-only access to data without needing to copy anything around.</p>
</blockquote>
<blockquote>
<p>The problem with slices is that Rust wants to know the size of every object in your program, and slices are defined as not having a compile-time size. References to the rescue. As mentioned in the discussion about the use of the term dynamically sized, slice size is fixed in memory. These are made up of two usize components (a pointer and a length). That’s why you typically see slices referred to in their referenced form, &amp;[T] (like string slices that take the notation &amp;str).</p>
</blockquote>
<blockquote>
<p>•Vec<u8>—A vector of raw bytes, usually created when consuming [u8] data. String is to Vec<u8> as str is to [u8].
Vectors (Vec<T>) are growable lists of T. Using vectors is extremely common in Rust code. These incur a small runtime penalty compared to arrays because of the extra bookkeeping that must be done to enable their size to change over time. But vectors almost always make up for this with their added flexibility.
Vec<T> performs best when you can provide it with a size hint via Vec::with_ capacity(). Providing an estimate minimizes the number of times memory will need to be allocated from the OS.
Lists of things are incredibly common. The two types that you will work with most often are arrays and vectors. Arrays are fixed-width and extremely lightweight.</p>
</blockquote>
<blockquote>
<p>Fully understanding the distinction between String and &amp;str requires knowledge of arrays and vectors. Textual data is similar to these two types with added convenience methods applied over the top.</p>
</blockquote>
<h2 id="avoid-iterator-index"><a class="header" href="#avoid-iterator-index">Avoid Iterator index</a></h2>
<blockquote>
<p>This is legal Rust. It’s also essential in cases when iterating directly over collection via for item in collection is impossible. However, it is generally discouraged. </p>
</blockquote>
<blockquote>
<p>The manual approach introduces two problems with this:
Performance—Indexing values with the collection[index] syntax incurs run-time costs for bounds checking. That is, Rust checks that index currently exists within collection as valid data. Those checks are not necessary when iterating directly over collection. The compiler can use compile-time analysis to prove that illegal access is impossible.</p>
</blockquote>
<blockquote>
<p>Safety—Periodically accessing collection over time introduces the possibility that it has changed. Using a for loop over collection directly allows Rust to guarantee that the collection remains untouched by other parts of the program.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];
assert_eq!(a.iter().nth(1), Some(&amp;2));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[clp-hashmap]]</p>
<p>[[mr-hashmap]]</p>
<p>[[ria-hashmap]]</p>
<hr />
<blockquote>
<p>The hashing algorithm used for hashing the keys of the HashMap type is based on the Robin hood open addressing scheme, &gt;but can be replaced with a custom hasher depending on the use case and performance</p>
</blockquote>
<h2 id="avoid-duplication"><a class="header" href="#avoid-duplication">Avoid Duplication</a></h2>
<blockquote>
<p>If we want to preserve the old values, especially if we want to update a key with no value, we can use entry() paired with or_insert()
Default setting which is using insert you will have any duplicated key or val. 
<code>map.insert(key, &quot;some value&quot;.into());</code>
but when we use entry(word).or_insert(0) that will make avoid duplicated k/v.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut map = HashMap::&lt;CompoundKey, String&gt;::new();
let tmp = map.entry(word).or_insert(0);
<span class="boring">}
</span></code></pre></pre>
<hr />
<blockquote>
<p>Snipped code</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>map.entry($1key_str$2).or_insert(10);,
map.entry(key).and_modify(|e| { *e += 2 });,
,
if let Entry::Occupied(o) = map.entry(key) {,
    *o.into_mut() += 2;,
},
*map.entry(key).or_insert(10)+=2;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[clp-arithmetic]]</p>
<p>[[mr_iter]]</p>
<p>[[rd-slice]]</p>
<hr />
<blockquote>
<p>A slice is a type which <strong>lacks ownership</strong>.
Slices are a <strong>generic way</strong> to get <strong>a view into a collection</strong> type. Most use cases are to get a read only access to a certain range of items in a collection type. A slice is basically <strong>a pointer or a reference</strong> that points to a continuous range in an existing collection type that’s owned by some other variable.</p>
<p>Under the hood, slices are #fat_pointer s to existing data somewhere in the stack or the heap. By fat pointer, it means that they also have information on <em>how many elements they are pointing to</em>, along with the pointer to the data.</p>
<p>we can’t have slices as bare values – only behind a pointer. This is because <strong>slices are unsized types</strong>.</p>
</blockquote>
<blockquote>
<p>Note: The &amp;str type also comes under the category of a slice type (a [u8]). The only distinction from other byte slices is that they are guaranteed to be UTF-8. Slices can also be taken on Vecs or Strings.</p>
</blockquote>
<blockquote>
<p>Slicing can be <strong>shared and immutable</strong>.</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> unsize</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-vec]]</p>
<hr />
<blockquote>
<p>Therefore, vectors are not in scope when using the following feature: <code>#![no_std]</code>.
A “Vec” type is shorthand for vector. Vectors are arrays that will dynamically expand when needed.
The underscore asks the the compiler to infer the type of the vector’s elements.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fields: Vec&lt;_&gt; = record 
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Make this a while let statement - remember that vector.pop also adds another layer of Option<T>
You can stack <code>Option&lt;T&gt;</code>’s into while let and if let</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(Some(value)) = optional_values_vec.pop() {
      println!(&quot;current value: {}&quot;, value);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr-linkedlist]]</p>
<p>[[rd-linkedlist]]</p>
<hr />
<blockquote>
<p>In the preceding diagram, we have two variables, var1 and var2, that reference two resources, Obj1 and Obj2. Along with that, Obj1 also has a reference to Obj2 and Obj2 has a reference to Obj1. Both Obj1 and Obj2 have reference count of 2 when var1 and var2 goes out of scope, the reference count of Obj1 and Obj2 reaches 1. They won’t get freed because they still refer to each other.</p>
</blockquote>
<p><img src="pointers/smartpointer/compiletime/shared_owner_locally/rc/linkedlist/../../../../../../rust/assets/images/tree-linkedlist.JPG" alt="LinkedList" /></p>
<blockquote>
<p>The reference cycle can be broken using weak references. As another example, a linked list might be implemented in such a way that it maintains links via reference counting to both the next item and to the previous. A better way to do this would be to <strong>use strong references to one direction and weak references to the other</strong>.</p>
</blockquote>
<blockquote>
<p>That changes a bit if we want to keep the structure this simple but <strong>still have a double-linked list</strong>, since then we actually have to change the existing structure.(<code>sample code</code> master-rust-linkedlist-main)</p>
</blockquote>
<blockquote>
<p>You can <strong>downgrade</strong> an Rc<T> type into a Weak<T> type with the downgrade method, and similarly a Weak<T> type can be turned into Rc<T> using the <strong>upgrade</strong> method.</p>
</blockquote>
<blockquote>
<p>The downgrade method will always work. In contrast, when calling upgrade on a weak reference, the actual value might have been dropped already, in which case you get a None.(<code>sample code</code> mater-rust-linkedlist-ex-1)</p>
</blockquote>
<blockquote>
<p>We could make append take a mutable reference to self, but that would mean that we could only append to the list if all the nodes’ bindings were mutable, forcing the whole structure to be mutable. What we really want is a way to make just one small part of the whole structure mutable, and fortunately we can do that with a single RefCell.(<code>sample code</code> mater-rust-linkedlist-ex-2)</p>
</blockquote>
<blockquote>
<blockquote>
<p>Whenever we’re using RefCell borrows, it’s a good practice to think carefully that we’re using it in a safe way, since making mistakes there may lead to runtime panics. In this implementation, however, it’s easy to see that we have just the single borrow, and that the closing block immediately discards it.</p>
</blockquote>
</blockquote>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<p>Apart from shared ownership, we can also get shared <strong>mutability at runtime</strong> with Rust’s concept of interior mutability, which are modeled by special wrapper smart pointer types.</p>
<h2 id="benchmark-for-the-linkedlists"><a class="header" href="#benchmark-for-the-linkedlists">Benchmark for the linkedlists</a></h2>
<pre><pre class="playground"><code class="language-rust  compiled_fail  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    extern crate test;
    use test::Bencher;

    #[bench]
    fn bench_list_append(b: &amp;mut Bencher) {
        let mut list = List::new_empty();
        b.iter(|| {
            list.append(10);
        });
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-commandline]]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[ARITHMETIC]]</p>
<p>[[IO]]</p>
<p>[[OPERATOR]]</p>
<p>[[SERDE]]</p>
<p>[[ria-data-csv-bin]]</p>
<p>[[ria-regex]]</p>
<p>[[clique]]</p>
<p>[[mr-operator]]</p>
<hr />
<blockquote>
<p>Tuple is to capture variables independently and put them into a structure.</p>
</blockquote>
<blockquote>
<p>`tags’ [[serde]] [[json]]  [[rmp_serde]] [[from_read_ref]] [[arithmetic]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-operator]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[AS]]</p>
<p>[[ria-texttoenum]]</p>
<hr />
<blockquote>
<p>Rust provides a trait named Into, which provides compile-time safe type conversions. For example, we can convert from a u32 to a u64 using the following code:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = u32::max_value(); 
let z : u64 = y.into();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust’s Into trait resolves the problem of potentially impossible conversions by not implementing them.</p>
</blockquote>
<blockquote>
<p>The inverse of the example—converting a u64 to a u32—is impossible with Into. If we try let z : u32 = (12_u64).into(), the into() function call will fail to compile. For conversions that may be possible, Rust provides another trait which is TryInto. The following code uses try_into() to attempt to convert between u64 and u32:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;
let z : u32 = (5000_u64).try_into().expect(&quot;Conversion error&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Using type casts carelessly will cause your program to behave unexpectedly. For example, the expression 300_i32 as i8 returns 44. </p>
</blockquote>
<ul>
<li>*BecauseOf(-): *BecauseOf(?): using as //300-128=172-128=44</li>
</ul>
<blockquote>
<p>try_into is better than ‘as’ because of error handling.
The try_into() method returns an i32 value wrapped within a Result.</p>
</blockquote>
<blockquote>
<p>unwrap: if this result does not emit an error. it will resolve with the value. unwrap in not suit for prod because input validation
The unwrap() method can handle the success value and returns the value of b as an i32 here</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[try_into]]</p>
</blockquote>
<h2 id="glossery-4"><a class="header" href="#glossery-4">Glossery</a></h2>
<blockquote>
<p>‘turbofish’:	::&lt;&gt;()  , ::. Combined with the (angular brackets=Bound) for generics</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-data-io-io]]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-data-file]]</p>
<p>[[pp-data-file]]</p>
<hr />
<h2 id="concepts"><a class="header" href="#concepts"><code>Concepts</code></a></h2>
<h2 id="higher-order-programming"><a class="header" href="#higher-order-programming">Higher-order programming</a></h2>
<p>Functions can both accept and return functions. includes a [[CLOSURE]], also known as an #anonymous_function or #lambda function.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code>let fields: Vec&lt;_&gt; = record
.split(',')
.map(|field| field.trim())
.collect();
</code></pre>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>Not included in release builds of the program.</p>
<p>[[conditional_compilation]]
[[cfg]]</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code>if cfg!(debug_assertions) {
eprintln!(&quot;debug: {:?} -&gt; {:?}&quot;,record, fields);
}
</code></pre>
<h2 id="conditionally-processing-data"><a class="header" href="#conditionally-processing-data">Conditionally processing data</a></h2>
<p>The if let construct is a concise method of conditionally processing data that also provides a local variable assigned to that data. The parse() method returns Ok(T) (where T stands for any type) when it can successfully parse the string; otherwise, it returns Err(E) (where E stands for an error type)</p>
<p>[[conditional_processing]]</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code>if let Ok(length) = fields[1].parse::&lt;f32&gt;() {     
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="data/regex/rust-in-action/ria-regex.html">ria-regex</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>[[clp-arithmetic]]</p>
<p>[[mr-arithmetic]]</p>
<hr />
<blockquote>
<p>By wrapping arithmetic, we mean that adding 1 to 255 (a u8) will result in 0.</p>
</blockquote>
<blockquote>
<p>When the programmer wants to allow <strong>wrapping</strong> semantics on arithmetic operations, then they may choose to ignore the panic and proceed to compile in <strong>release</strong> mode. That’s another aspect of #safety that the language provides you.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[serde_json]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-copy-clone]]</p>
<p>[[ria-rc]]</p>
<hr />
<p>One alternative to refactoring is to simply copy values. Doing this often is typically frowned upon, however, but it can be useful in a pinch. Primitive types like integers are a good example of that. Primitive types are cheap for a CPU to duplicate—so cheap, in fact, that Rust always copies these if it would otherwise worry about ownership being moved.</p>
<p>Types can opt into two modes of duplication: cloning and copying.</p>
<div style="break-before: page; page-break-before: always;"></div><h2>[[ria-copy-clone]]
[[pnkfx-copy-clone]]
[[edu-copy-clone]]
[[SEMANTIC]]</h2>
<h1 id="semantics"><a class="header" href="#semantics">Semantics</a></h1>
<p>Move semantics: A value that gets moved to the receiving item when accessed through a variable or reassigning to a variable exhibits move semantics. Rust has move semantics  by default due to its affine type system. A highlighting part of affine type systems is that values or resources can only be used once, and Rust exhibits this <strong>property with the ownership rule.</strong></p>
<p>Copy semantics: A value that gets copied (as in a bitwise copy) by default when assigned or accessed through a variable or passed to/returned from a function exhibits copy semantics. <strong>This means that the value can be used any number of times and each value is completely new</strong>.</p>
<h2 id="copy"><a class="header" href="#copy">Copy</a></h2>
<p>So why do Rust programmers not always use Copy? There are three main reasons:</p>
<p>The Copy trait implies that there will only be negligible performance impact. This is true for numbers but not true for types that are arbitrarily large, such as String.Because Copy creates exact copies, it cannot treat references correctly. </p>
<p>Naïvely <em>copying a reference to T would (attempt to) create a second owner of T</em>. </p>
<p>That would cause problems later on because there would be multiple attempts to delete T as each reference is deleted.</p>
<p>It appears that Copy depends on the Clone trait. This is because Copy is defined in the standard library as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}
</span></code></pre></pre>
<p>Copy is an auto trait that is implemented automatically on most stack data types such as <strong>primitives and immutable references</strong> but <strong>Types that don’t implement Copy are Vec<T></strong>, String, and mutable references. To make copies of these values, we use the more explicit Clone trait.</p>
<p>Items such as <strong>String and Vec that are heavy to copy</strong>, only implements  the Clone trait. <strong>Smart pointer types also implement the Clone trait</strong> where they just copy the pointer and extra metadata such as the reference count while pointing to the same heap data</p>
<h2 id="clone"><a class="header" href="#clone">Clone</a></h2>
<p>When to implement Clone on a type:</p>
<p>The Clone trait merely declares a clone method, which needs to be called <strong>explicitly</strong>.</p>
<p>If your type also contains a value on the heap as part of its representation, then opt for implementing Clone, which makes it <strong>explicit to users</strong> that will also be <em>cloning the heap data</em>.</p>
<p>If you are implementing a <strong>smart pointer</strong> type <em>such as a reference counting type, you should implement Clone on your type to only copy the pointers on the stack</em>.</p>
<h2 id="shallow-copy-vs-deep-copy"><a class="header" href="#shallow-copy-vs-deep-copy">Shallow copy VS Deep copy</a></h2>
<p>Concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow [[copy]] . If a type implements the Copy trait, a variable is still valid after assignment to another variable.</p>
<p>If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.</p>
<h3 id="clone-vs-copy"><a class="header" href="#clone-vs-copy">Clone Vs Copy</a></h3>
<p><strong>Without Copy, Rust applies move semantics to a type’s access</strong>. When using [[Clone]], copying data is explicit.Until a type implements either Copy or Clone, its internal data cannot be copied.</p>
<p>Types can opt into two modes of duplication: cloning and copying.</p>
<pre><code class="language-no_run compile_fail">Cloning (std::clone::Clone) 
May be slow and expensive.
Never implicit. A call to the .clone() method is always required. 
May differ from original. Crate authors define what cloning means for their types.
</code></pre>
<p>Here are some of the types that implement Copy:</p>
<ul>
<li>All the integer types, such as u32.</li>
<li>The Boolean type, bool, with values true and false.</li>
<li>All the floating point types, such as f64.</li>
<li>The character type, char.</li>
<li>Tuples, if they only contain types that also implement Copy.</li>
<li>For example,** (i32, i32)** implements Copy(because all of [[primitive]] types are fix size so they <strong>store on stack</strong>), but (i32, String) does not.</li>
</ul>
<pre><code class="language-no_run compile_fail">Copying (std::marker::Copy)
Always fast and cheap.
Always implicit.
Always identical. 
Copies are bit-for-bit duplicates of the original value.
</code></pre>
<h3 id="copy-vs-vec-vs-slice"><a class="header" href="#copy-vs-vec-vs-slice">Copy Vs Vec Vs Slice</a></h3>
<p>In Rust Copy has a specific meaning of <strong>duplicating bytes without doing any additional bookkeeping</strong>. Vec is fundamentally incompatible with this, because it owns heap-allocated storage, which must have only one and exactly one owner. If it was allowed to be Copy, it’d be unclear which of the copies is the last one to free the storage.</p>
<p>Slice &amp;[] can be Copy, because it doesn’t free the storage.</p>
<h3 id="handle-error-of-copy"><a class="header" href="#handle-error-of-copy">Handle error of Copy</a></h3>
<p>But if the compiler is telling you to make something Copy, that’s just a suggestion. You don’t have to do this. You may have just misunderstanding of ownership, and you could avoid the need to copy by reorganizing your code, e.g.</p>
<ul>
<li>using shared references</li>
<li>using a different data structure</li>
<li>moving values to different structs or scopes.It depends on the situation.</li>
</ul>
<pre><code class="language-rust compile_fail no_run ignore">#[derive(Debug)]
struct Foo;

fn main() {
    let a = Foo;

    let closure = move || {
        let b = a;
        b
    };

    println!(&quot;{:?}&quot;, a); //error
    println!(&quot;{:?}&quot;, b);//error
    println!(&quot;{:?}&quot;, closure());//no error
}

</code></pre>
<h2 id="glossery-5"><a class="header" href="#glossery-5">Glossery</a></h2>
<p><code>implicit</code>:	encapsulation (like method, copy)</p>
<hr />
<p><code>tags</code> [[semantic]] [[move]] [[copy]] [[clone]]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc-1"><a class="header" href="#rc-1">RC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recoverable"><a class="header" href="#recoverable">Recoverable</a></h1>
<p>[[ria-errorhandling]]</p>
<p>[[clp-errorhandling]]</p>
<p>[[edu-errorhandling]]</p>
<p>[[rip-errorhandling]]</p>
<p>[[rd-errorhandling]]</p>
<p>[[mr-errorhandling]]</p>
<h1 id="non-recoverable"><a class="header" href="#non-recoverable">Non-Recoverable</a></h1>
<p>[[mr-non-recoverable-errorhandling]]</p>
<hr />
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<blockquote>
<p>Most error handling, in general, falls into three categories:</p>
</blockquote>
<ul>
<li><strong>Recoverable</strong> errors that are expected to happen due to the <strong>user and the environment</strong> interacting with the program, for example,<strong>a file not found error or a number parse error. Option and Result</strong> for recoverable errors</li>
<li><strong>Non-recoverable</strong> errors that violate the contracts or invariants of the program, for example, <strong>index out of bounds or divide by zero non-recoverable errors, there’s a mechanism called panic</strong>.</li>
<li><strong>Fatal errors</strong> that abort the program immediately. Such situations include <strong>running out of memory, and stack overflow.</strong></li>
</ul>
<blockquote>
<p>Rust does not have the notion of #null values, which is infamously quoted as being the #billion-dollar mistake by #Tony_Hoare, who introduced null references in the ALGOL W language back in 1965.</p>
</blockquote>
<blockquote>
<p>As an <strong>enum</strong>, they get the ability to store a success state and an error state, while generics allow them to specialize <strong>at compile time</strong> so that they store any value in either state. These types also come with a lot of convenient methods (commonly known as <strong>combinators</strong>) implemented on them, allowing you to consume, compose, or transform the inner values easily.</p>
</blockquote>
<blockquote>
<p>encouraged to read and become familiar with their type signature by referring to their documentation:</p>
</blockquote>
<ul>
<li>
<p><strong>map_err:</strong> This method acts only on Result types and allows <strong>transforming the failed value from E to some other type</strong>, H, but only if the value is an Err value. <strong>map_err is not defined for Option types</strong>, as doing anything with None would be pointless.</p>
</li>
<li>
<p><strong>and_then:</strong> In the case of a failed value, this returns the value as is, but in the case of a successful value, this takes in a closure as the second argument, which acts on the wrapped value and returns the wrapped type. This is useful when <strong>you need to perform transformations on the inner values,</strong> one after another.</p>
</li>
<li>
<p><strong>unwrap_or:</strong> This method <strong>extracts the inner success value</strong>, or returns a default one if it’s a failed value. You provide the default value to it as a second argument.</p>
</li>
<li>
<p><strong>unwrap_or_else:</strong> This method acts the same as the preceding method but computes a different value when it is a failed value by taking a closure as the second argument. In the standard library documentation. Many more of these methods can clean up huge nested match expressions when you’re dealing with errors.</p>
</li>
<li>
<p><strong>as_ref:</strong> This method <strong>converts the inner value to a reference</strong> and returns the wrapped value, that is, an Option&lt;&amp;T&gt; or a Result&lt;&amp;T, &amp;E&gt;.</p>
</li>
<li>
<p><strong>or/ or_else:</strong> These methods return the value as is if it’s a success value, or returns an alternative Ok/Some value, which is provided as the second argument. or_else accepts a closure within which you need to <strong>return a success value</strong>.</p>
</li>
<li>
<p><strong>as_mut:</strong> This method <strong>converts the inner value into a mutable reference</strong> and returns the wrapped value, that is, an Option&lt;&amp;mut T&gt; or a Result&lt;&amp;mut T, &amp;mut E&gt;.
&gt;&gt; There are many more that are unique to the Option and Result types.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>ok_or</strong>: This method <strong>converts an Option value to a Result value</strong>, by taking in an error value as a second parameter. A similar variant to this is the ok_or_else method, which should be preferred over this, as it computes the value lazily by taking in a closure.</p>
</li>
<li>
<p><strong>ok</strong>: This method converts a Result into an Option consuming self, and <strong>discards the Err value</strong>.</p>
</li>
</ul>
<h2 id="operator-"><a class="header" href="#operator-">Operator ?</a></h2>
<p>There is a important notice based on this examples about ?</p>
<ul>
<li><code>master-rust-error-handling-ex-4</code></li>
<li><code>master-rust-error-handling-ex-5</code></li>
</ul>
<blockquote>
<blockquote>
<p>The ? operator abstracts this pattern, making it possible to write the <strong>bytes_to_str</strong> method in a more concise way</p>
</blockquote>
</blockquote>
<blockquote>
<p>we want to make an early return and propagate the error to the caller.</p>
</blockquote>
<blockquote>
<p>The error message also mentioned that ? can be used with Option<T> values as well. As with using ? on Result, you can only use ? on Option in a function that returns an Option. The behavior of the ? operator when called on an Option<T> is similar to its behavior when called on a Result&lt;T, E&gt;: if the value is None, the None will be returned early from the function at that point. If the value is Some, the value inside the Some is the resulting value of the expression and the function continues.
This pattern of propagating errors is so common in Rust that Rust provides the question mark operator ? to make this easier.</p>
</blockquote>
<blockquote>
<p>Sample : propagating errors</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; Ok(s),
    Err(e) =&gt; Err(e),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>what the ? operator does: error values that have the ? operator called on them go through the from function, defined in the From trait in the standard library, which is used to convert errors from one type into another. When the ? operator calls the from function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as there’s an impl From<OtherError> for ReturnedError to define the conversion in the trait’s from function, the ? operator takes care of calling the from function automatically.</p>
</blockquote>
<blockquote>
<p>In the context of Listing 9-7, the ? at the end of the File::open call will return the value inside an Ok to the variable f. If an error occurs, the ? operator will return early out of the whole function and give any Err value to the calling code. The same thing applies to the ? at the end of the read_to_string call.</p>
</blockquote>
<blockquote>
<p>The ? operator eliminates a lot of boilerplate and makes this function’s implementation simpler. We could even shorten this code further by chaining method calls immediately after the ?</p>
</blockquote>
<blockquote>
<p>Either option&amp;result :
you can’t mix and match. The ? operator won’t automatically convert a Result to an Option or vice versa; in those cases, there are methods like the ok method on Result or the ok_or method on Option that will do the conversion explicitly.</p>
</blockquote>
<h2 id="warning-handling"><a class="header" href="#warning-handling">Warning Handling</a></h2>
<blockquote>
<p>We have two ways of <strong>handling this warning:</strong></p>
</blockquote>
<ul>
<li>Handle both the Ok and Err cases as before for the Result value returned by the read_to_string method</li>
<li>Assign the return value to a special variable _ (underscore), which lets the compiler know that we want to ignore the value</li>
</ul>
<p>For cases where we don’t care about the value, we can use the second approach and so the read_to_string line changes as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = file.read_to_string(&amp;mut s);
<span class="boring">}
</span></code></pre></pre>
<p>With that change, the code compiles without warnings. However, you should handle the return value and try not to use the catch all underscore variable.</p>
<h2 id="anyhow-library"><a class="header" href="#anyhow-library">Anyhow Library</a></h2>
<blockquote>
<p>The problem with the ? operator is that all errors have to be the same type to work. However, in most cases, we have to deal with different error types. To solve that, we can use the crate anyhow.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">

// This is the same function we've seen in the lesson, but we are 
// serializing a json object, taking the value and sum it with the argument.
// Without anyhow this code would have a lot of more lines of code.
use anyhow::{anyhow, Result};
use serde_json::Value;
fn sum_numbers(number: &amp;str) -&gt; Result&lt;i32&gt; {
    let num = number.parse::&lt;i32&gt;()?;
    let num_json: Value = serde_json::from_str(&quot;{\&quot;one\&quot;: 12}&quot;)?;
    let get_number = num_json.get(&quot;one&quot;).ok_or(anyhow!(&quot;Error getting number&quot;))?;
    let num2: i32 = serde_json::from_value(get_number.clone())?;
    Ok(num + num2)
}
fn main() {
    println!(&quot;sum two numbers: {:#?}&quot;, sum_numbers(&quot;567&quot;));
}
</code></pre></pre>
<p>Now, things start to get a little bit complicated, but we can follow it. In the above code, we parse a number from a &amp;str type value. This would produce a FromStr::Error type in case of error, which is very different from the error we can obtain from line 6.</p>
<p>In line 7, the method get will return an Option type. We need to convert it to a Result with ok_or. This way, we can use the anyhow crate.</p>
<p>Finally, in line 8, we get a different error.</p>
<h2 id="difference-between-println-vs-eprintln"><a class="header" href="#difference-between-println-vs-eprintln">Difference between println! vs eprintln!</a></h2>
<p>Macro std::eprintln</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! eprintln {
    () =&gt; { ... };
    ($fmt:expr) =&gt; { ... };
    ($fmt:expr, $($arg:tt)*) =&gt; { ... };
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro for printing to the standard error, with a newline.
Equivalent to the println! macro, except that output goes to <strong>io::stderr instead of io::stdout</strong>. See println! for example usage.
Use eprintln! only for error and progress messages. Use println! instead for the primary output of your program.
Panics</p>
<p><code>Panics if writing to io::stderr fails.</code></p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>eprintln!(&quot;Error: Could not complete task&quot;);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><code>rustc --explain E0599</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr-non-recoverable-errorhandling]]</p>
<hr />
<p>When code that’s in the execution phase encounters a bug, or one of its variants is violated, it has the potential to corrupt the program state in unexpected ways if it’s ignored. These situations are deemed non-recoverable because of their inconsistent program state, which may <strong>lead to faulty outputs or unexpected behavior later</strong>. </p>
<blockquote>
<p>This means that a fail-stop approach is the best way to recover from them so as to not harm other parts or systems indirectly.
For these kinds of cases, Rust provides us with a mechanism called panic, which aborts the thread on which it is <strong>invoked and does not affect any other threads</strong>. If the main thread is the one facing the panic, then the program aborts with a non-zero exit code of 101. If it’s a child thread, the panic does not propagate to the parent thread and halts at the thread boundary. 
A panic in one thread does not affect the other threads and is isolated, except in cases where they corrupt a mutex lock on some shared data; it is implemented as a macro by the same panic! mechanism.</p>
</blockquote>
<blockquote>
<p><strong>Unwinding</strong> is the process of moving up the function call chain while <strong>cleaning up or freeing resource</strong>, from each function call stack.</p>
</blockquote>
<blockquote>
<p>When panic! is called, <strong>the panicking thread starts unwinding the function call stack</strong>, starting from the place at which it was invoked, all the way until the entry point in the thread. It also generates a stack trace or a backtrace for all functions that are invoked in this process, just like exceptions. But in this case, it does not have to look for any exception handlers, as they don’t exist in Rust. </p>
</blockquote>
<blockquote>
<p>These resources can be stack allocated or heap allocated. Stack allocated resources automatically get released once the function ends. For variables pointing to heap allocated resources, Rust calls the drop method on them, which frees up the memory used by the resource. </p>
</blockquote>
<blockquote>
<p><strong>This cleanup is necessary to avoid memory leaks</strong>. Apart from code calling panic explicitly, Result/Option error types also call panic if any code does.</p>
</blockquote>
<p>In the case of <strong>single-threaded</strong> code having panics on the main thread, <strong>unwinding doesn’t provide much of a benefit</strong>, as the operating system reclaims all the memory after the process aborts. </p>
<blockquote>
<p>Fortunately, there are options to <strong>turn off unwinding in panic</strong>, which may be required on platforms such as <strong>embedded systems</strong>, where we have a single main thread doing all the work and where unwinding is an expensive operation that isn’t of much use.</p>
</blockquote>
<p>To figure out the sequence of calls that led to the panic, we can view the backtrace from the thread by running any panicking program and setting the <strong>RUST_BACKTRACE=1</strong> environment variable from our command-line shell.</p>
<blockquote>
<p>you can use the std::panic::catch_unwind function. Even though it’s recommended to handle errors via the Option/Result mechanism.</p>
</blockquote>
<blockquote>
<p><code>catch_unwind</code> doesn’t prevent the panic – it only allows you to <strong>customize the unwind behavior</strong> associated with panic. panic with <strong>catch_unwind is not recommended as a general error handling</strong> method for Rust programs.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn catch_unwind&lt;F: FnOnce() -&gt; R + UnwindSafe, R&gt;(f: F) -&gt; Result&lt;R&gt; 
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, the return value of <strong>catch_unwind</strong> has an additional constraint, UnwindSafe. This means that the variables in the closure must be exception-safe, which most types are, but notable exceptions are mutable references (&amp;mut T). A value is exception safe if exception-throwing code cannot lead to the value being left in an inconsistent state. This means that the <strong>code inside the closure must not panic!() itself</strong>.</p>
<p>it just <strong>stops the unwinding associated with the panicking thread</strong>. Note again that catch_unwind is not the recommended method for error management in Rust. It is not guaranteed to catch all panics, such as panics that abort the program. </p>
<blockquote>
<blockquote>
<p>Catching panic unwinding is <strong>necessary</strong> in situations where Rust code is communicating with other languages such as C, **where unwinding to C code **is an undefined behavior.</p>
</blockquote>
</blockquote>
<blockquote>
<p>The program can then resume the unwind by using the <strong>resume_unwind</strong> function from the same panic module.</p>
</blockquote>
<p>For rare cases where the default unwinding behavior of panic can get too expensive, such as when writing programs for microcontrollers, <em>there’s a compiler flag that can be configured to turn all panics into aborts</em>. To do that, your project’s Cargo.toml needs to have the following attribute under the profile.release section:</p>
<pre><code>[profile.release]
panic = &quot;abort&quot;
</code></pre>
<h3 id="user-friendly-panics"><a class="header" href="#user-friendly-panics">User-Friendly Panics</a></h3>
<p>verbose, cryptic panic messages with human-readable messages. It also <em>writes the backtrace to a file</em> to allow it to be reported to the tool author by users.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[clp-feature-dryoc]]</p>
<p>[[rd-feature-shapes-lib]]</p>
<p>[[rd-macro-fearues]]</p>
<p>[[rd-carg-metadata]]</p>
<hr />
<h2 id="feature-rust-for-what"><a class="header" href="#feature-rust-for-what">Feature Rust for what?</a></h2>
<p>To express conditional compilation and optional dependencies.
The ability to pick compile time features in Rust can improve your code’s performance, size, maintainability, safety, and portability.
Features for the package being built can be enabled on the command-line with flags such as <code>--features</code></p>
<ul>
<li>The <code>--no-default-features</code> command-line flag disables the default features of the package.</li>
<li>The <code>default-features = false</code> option can be specified in a dependency declaration.</li>
<li><code>--all-features</code>: Activates all features of all packages selected on the command-line.</li>
</ul>
<h2 id="caution"><a class="header" href="#caution">Caution</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Dependencies automatically enable default features unless <code>default-features = false</code> is specified.</li>
<li><input disabled="" type="checkbox" checked=""/>
Another issue is that it can be a <code>SemVer incompatible change</code> to remove a feature from the default set, so you should be confident that you will keep those features.</li>
</ul>
<blockquote>
<p>A different feature resolver can be specified with the resolver field in Cargo.toml, like this:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Dependencies can be marked <code>optional</code>, <strong>which means they will not be compiled by default</strong> except using <code>--features name</code> to enable dependency that has <code>optional</code> field.</li>
<li><input disabled="" type="checkbox" checked=""/>
There are rare cases where features may be mutually incompatible with one another. consider adding a compile error to detect this scenario. For example:</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(all(feature = &quot;foo&quot;, feature = &quot;bar&quot;))]
compile_error!(&quot;feature \&quot;foo\&quot; and feature \&quot;bar\&quot; cannot be enabled at the same time&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>When there is a conflict, choose one feature over another. The <strong>cfg-if</strong> package can help with writing more complex cfg expressions.</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
For example, if you want to optionally support no_std environments, do not use a no_std feature. Instead, use a std feature that enables std. For example:</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[cfg(feature = &quot;std&quot;)]
extern crate std;

#[cfg(feature = &quot;std&quot;)]
pub fn function_that_requires_std() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
ravif = { version = &quot;0.6.3&quot;, optional = true }
rgb = { version = &quot;0.8.25&quot;, optional = true }

[features]
avif = [&quot;dep:ravif&quot;, &quot;dep:rgb&quot;]
<span class="boring">}
</span></code></pre></pre>
<p>In above example, the avif feature will enable the two listed dependencies. This also avoids creating the implicit ravif and rgb features, since we don’t want users to enable those individually as they are internal details to our crate.</p>
<h3 id="dependency-features"><a class="header" href="#dependency-features">Dependency features</a></h3>
<p>Features of dependencies can be enabled within the dependency declaration. The features key indicates which features to enable:</p>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
<span class="boring">Enables the `derive` feature of serde.
</span>serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }
<span class="boring">}
</span></code></pre></pre>
<p>The default features can be disabled using default-features = false:</p>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
flate2 = { version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] }
<span class="boring">}
</span></code></pre></pre>
<p>Features of dependencies can also be enabled in the [features] table. The syntax is “package-name/feature-name”. For example:</p>
<pre><pre class="playground"><code class="language-rust no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
jpeg-decoder = { version = &quot;0.1.20&quot;, default-features = false }

[features]
//Enables parallel processing support by enabling the &quot;rayon&quot; feature of jpeg-decoder.
parallel = [&quot;jpeg-decoder/rayon&quot;]
<span class="boring">}
</span></code></pre></pre>
<p>The “package-name/feature-name” syntax will also enable package-name if it is an optional dependency. Often this is not what you want. You can add a ? as in <code>&quot;package-name?/feature-name&quot;</code> which will only enable the given feature if something else enables the optional dependency.</p>
<blockquote>
<p>Note: The ? syntax is only available starting with Rust 1.60.</p>
</blockquote>
<h2 id="how-does-cc-compare"><a class="header" href="#how-does-cc-compare">How Does C/C++ Compare?</a></h2>
<p>C++ does not have a built-in feature directly equivalent to the ability to pick compile time features in Rust. However, C++ does have a number of preprocessor directives that can be used to include or exclude certain code at compile time selectively.</p>
<h1 id="how-to-implement"><a class="header" href="#how-to-implement">How to implement?</a></h1>
<p>Code of <code>#[cfg(feature = &quot;my-feature&quot;)]</code> is used for a function or module. It is feasable to enable a feature flag for a specific struct or enum, a test/benchmark case, and a specific implementation of a trait as well.</p>
<p>To enable a feature only when multiple flags are set, you can use the </p>
<blockquote>
<p><code>#[cfg(all(feature1, feature2, ...))].</code></p>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// SubFolder monitor mod.rs
//! Signal monitor
#[cfg(unix)]
#[path = &quot;unix.rs&quot;]
mod imp;

#[cfg(windows)]
#[path = &quot;windows.rs&quot;]
mod imp;

#[cfg(not(any(windows, unix)))]
#[path = &quot;other.rs&quot;]
mod imp;

pub use self::imp::create_signal_monitor;
//unix.rs or windows.rs or other.rs
pub fn create_signal_monitor(){
    unimplemented!();
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example 2</a></h2>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> //Enables use statement only when serde is enabled.
 #[cfg(feature = &quot;serde&quot;)]
 use serde::{Deserialize, Serialize};

 use zeroize::Zeroize;


 // Enables the derive() statement only when serde is enabled.
 #[cfg_attr(
     feature = &quot;serde&quot;,
     derive(Serialize, Deserialize, Zeroize, Debug, PartialEq)
 )] // B
 //Enables the derive() statement only when serde is disabled.
 #[cfg_attr(not(feature = &quot;serde&quot;), derive(Zeroize, Debug, PartialEq))]
 #[zeroize(drop)]
 //Message container, for use with unencrypted messages
 pub struct Message(pub Box&lt;InputBase&gt;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="example-3"><a class="header" href="#example-3">Example 3</a></h2>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;shapes&quot;)]
pub mod shapes {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;], optional = true , default-features = true}
rgb = { version = &quot;0.8.25&quot;, features = [&quot;serde&quot;], optional = true , default-features = true}
[features]
default = [&quot;shapes&quot;]
color = [&quot;dep:rgb&quot;]
shapes = [&quot;color&quot;, &quot;dep:serde&quot;, &quot;rgb?/serde&quot;]
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2 id="making-featured-everythings"><a class="header" href="#making-featured-everythings">Making Featured Everythings</a></h2>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Memory allocator
#[cfg(feature = &quot;jemalloc&quot;)]
#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
#[cfg(feature = &quot;tcmalloc&quot;)]
#[global_allocator]
static ALLOC: tcmalloc::TCMalloc = tcmalloc::TCMalloc;
#[cfg(feature = &quot;mimalloc&quot;)]
#[global_allocator]
static ALLOC: mimalloc::MiMalloc = mimalloc::MiMalloc;
#[cfg(feature = &quot;snmalloc&quot;)]
#[global_allocator]
static ALLOC: snmalloc_rs::SnMalloc = snmalloc_rs::SnMalloc;
#[cfg(feature = &quot;rpmalloc&quot;)]
#[global_allocator]
static ALLOC: rpmalloc::RpMalloc = rpmalloc::RpMalloc
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>In this example, you see how to let your users “layer in” the functionality they need, where you can pick how much deeper you want to go:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Service launchers
pub mod genkey;
#[cfg(feature = &quot;local&quot;)]
pub mod local;
#[cfg(feature = &quot;manager&quot;)]
pub mod manager;
#[cfg(feature = &quot;server&quot;)]
pub mod server;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>In the below example, you can use blocks to “artificially” scope in entire pieces of code under a feature:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;local-tunnel&quot;)]
{
    app = app.arg(
        Arg::new(&quot;FORWARD_ADDR&quot;)
            .short('f')
            .long(&quot;forward-addr&quot;)
            .num_args(1)
            .action(ArgAction::Set)
            .requires(&quot;LOCAL_ADDR&quot;)
            .value_parser(vparser::parse_address)
            .required_if_eq(&quot;PROTOCOL&quot;, &quot;tunnel&quot;)
            .help(&quot;Forwarding data directly to this address (for tunnel)&quot;),
    );
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="debug_assertions"><a class="header" href="#debug_assertions">debug_assertions</a></h2>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When debugging is enabled, include this code block. The exclamation mark (!) indicates a macro invocation. 
        if cfg!(debug_assertions) { 
            eprintln!(&quot;debug: {:?} -&gt; {:?}&quot;, record, fields); 
// eprintln! prints to standard error. The {:?} syntax requests Rust print out the default debugging representation for the two types.
        }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[LOOP]]</p>
<p>[[WHILE]]]</p>
<p>[[MATCH]]</p>
<p>[[pnfx-flowcontrol]]</p>
<hr />
<h2 id="iter-vs-for-performance"><a class="header" href="#iter-vs-for-performance">Iter Vs For performance</a></h2>
<p><code>test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)</code>
&gt;
<code>test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)</code>
&gt;
<code>The iterator version was slightly faster! We won’t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</code>
&gt;</p>
<pre><code>use std::mem;
println!(&quot; size_of::&lt;&amp;[i32; 9]&gt;() == {:2} bytes&quot;, mem::size_of::&lt;&amp;[i32; 9]&gt;());
println!(&quot;      size_of::&lt;&amp;[i32]&gt;() == {:2} bytes&quot;, mem::size_of::&lt;&amp;[i32]&gt;());
</code></pre>
<blockquote>
<p>Result:</p>
</blockquote>
<pre><code>size_of::&lt;&amp;[i32; 9]&gt;() ==  8 bytes
size_of::&lt;&amp;[i32]&gt;() == 16 bytes
</code></pre>
<blockquote>
<p><code>tags</code> [[benchmark]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-for]]</p>
<hr />
<p>Shorthand</p>
<p>Equivalent to</p>
<p>Access</p>
<p>Ownership:</p>
<pre><code>for item in collection
for item in #IntoIterator :: #into_iter (collection)
</code></pre>
<p>Read-only:</p>
<pre><code>for item in &amp;collection
for item in collection.iter()
</code></pre>
<p>Read-write:</p>
<pre><code>for item in &amp;mut collection
for item in collection. #iter_mut()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[pp-loop]]]</p>
<p>[[loop/rust-in-action/ria-loop]]</p>
<hr />
<p>Rust contains a loop keyword for providing more control than for and while. loop executes a code block again and again, never stopping for a tea (or coffee) #break. loop continues to execute until a break keyword </p>
<blockquote>
<p>loop is often seen when implementing <strong>long-running servers</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-while]]</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[match_binding]] [[rd-match]] #scrutinee</p>
</blockquote>
<hr />
<h2 id="match-bindings"><a class="header" href="#match-bindings">Match Bindings</a></h2>
<p><a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#nicer-match-bindings">nicer-match-bindings</a></p>
<blockquote>
<p><code>self</code> has type <code>&amp;List</code>, and <code>*self</code> has type <code>List</code>, matching on a concrete type <code>T</code> is preferred over a match on a reference <code>&amp;T</code> after Rust 2018 you can use self here and tail (with no ref) below as well,rust will infer &amp;s and ref tail. 
the compiler automatically references the Some, and since we’re borrowing, name is bound as ref name automatically as well. If we were mutating:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello(arg: &amp;mut Option&lt;String&gt;) {
    match arg {
        Some(name) =&gt; name.push_str(&quot;, world&quot;),
        None =&gt; (),
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The compiler will automatically borrow by mutable reference, and name will be bound as ref mut too.</p>
</blockquote>
<h2 id="concise_control"><a class="header" href="#concise_control">Concise_control</a></h2>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
if let Some(max) = config_max {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="a-match-with-an-arm"><a class="header" href="#a-match-with-an-arm">A match with an Arm</a></h3>
<p>But what use is a type you can never create values for? Recall the code from Listing 2-5, part of the number guessing game; we’ve reproduced a bit of it here in Listing 19-26.</p>
<blockquote>
<p>A match with an arm that ends in continue:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,            
        };
<span class="boring">}
</span></code></pre></pre>
<p>At the time, we skipped over some details in this code. In Chapter 6 in “The match Control Flow Operator” section, we discussed that match arms must all return the same type. So, for example, the following code doesn’t work:</p>
<blockquote>
<p>This code does not compile!</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}
</span></code></pre></pre>
<p>As you might have guessed, continue has a ! value. That is, when Rust computes the type of guess, it looks at both match arms, the former with a value of u32 and the latter with a ! value. Because ! can never have a value, Rust decides that the type of guess is u32.</p>
<p>The formal way of describing this behavior is that expressions of type ! can be coerced into any other type. We’re allowed to end this match arm with continue because continue doesn’t return a value; instead, it moves control back to the top of the loop, so in the Err case, we never assign a value to guess.</p>
<h2 id="a-match-with-panic"><a class="header" href="#a-match-with-panic">A match with Panic</a></h2>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust sees that val has the type T and <strong>panic! has the type !</strong>, so the result of the overall match expression is T. This code works because <strong>panic! doesn’t produce a value</strong>; it ends the program. In the None case, we won’t be returning a value from unwrap, <strong>so this code is valid</strong>. [[panic]]</p>
<p>One final expression that has the <strong>type ! is a loop</strong>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Here, the loop never ends, so ! is the value of the expression. However, this wouldn’t be true if we included a break, because the <em>loop would terminate when it got to the break</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[CLOSURE]]</p>
<p>[[FUNCTION]]</p>
<p>[[LAZY]]</p>
<p>[[EXPRESSION]]</p>
<hr />
<h2 id="expression"><a class="header" href="#expression">Expression</a></h2>
<blockquote>
<p>{}; is a expression
An expression is evaluated to a value of a specific type.
Every expression must evaluate to a value. So, the println! macro call must produce a result. The thing is, it doesn’t have anything useful to produce.so the result will be unit().
a function call order_pokeballs(12): That would be the effect of evaluating that expression.
x=2+3 that is result.
Example [[unit]] of main</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">fn main() -&gt; () {
    println!(&quot;3 * 2 == {}&quot;, double(3));
}
</code></pre></pre>
<h2 id="jargon"><a class="header" href="#jargon">Jargon</a></h2>
<blockquote>
<p>Functional programming jargon: “to cons x onto y” informally means to construct a new container instance by putting the element x at the start of this new container, followed by the container y.</p>
</blockquote>
<blockquote>
<p>Vec<T> is a better choice to use. Other, more complex recursive data types are useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run_compile_fail edition2021">enum List {
    Cons(i32, List),
    Nil,
}

fn main() {}
</code></pre></pre>
<h2 id="func-vs-closure"><a class="header" href="#func-vs-closure">Func Vs Closure</a></h2>
<blockquote>
<p>Unlike closures, fn is a type rather than a trait</p>
</blockquote>
<blockquote>
<p>Functions can implement all three of the Fn traits too. </p>
</blockquote>
<ul>
<li>If what we want to do doesn’t require capturing a value from the environment,</li>
<li>we can use a function rather than a closure where we need something that implements an Fn trait.</li>
<li>in the case of closure it will cache the resulting value so the rest of our code doesn’t have to be responsible for saving and reusing the result. You may know this pattern as memoization or lazy evaluation.but there is a little a bit issue about closure that is good using memory for caching and avoid call fun but:</li>
</ul>
<blockquote>
<ul>
<li>When a closure captures a value from its environment,</li>
</ul>
</blockquote>
<ul>
<li>it uses memory to store the values for use in the closure body. </li>
<li>This use of memory is overhead</li>
</ul>
<blockquote>
<ul>
<li>All closures implement FnOnce because they can all be called at least once. </li>
</ul>
</blockquote>
<ul>
<li>Closures that don’t move the captured variables also implement FnMut,</li>
<li>and closures that don’t need mutable access to the captured variables also implement Fn</li>
</ul>
<hr />
<h2 id="glossery-6"><a class="header" href="#glossery-6">Glossery</a></h2>
<blockquote>
<p><code>Combinator</code>: As an <strong>enum</strong>, they get the ability to store a success state and an error state, while generics allow them to specialize <strong>at compile time</strong> so that they store any value in either state. These types also come with a lot of convenient methods (commonly known as <strong>combinators</strong>) implemented on them, allowing you to consume, compose, or transform the inner values easily.
Combinators are higher-order functions that apply only functions and earlier defined combinators to provide a result from its arguments. They can be used to manage control flow in a modular fashion.</p>
</blockquote>
<blockquote>
<p><a href="https://kerkour.com/rust-combinators">Rust Combinators</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>Scrutinee</code>: A scrutinee is the expression that is matched on in match expressions and similar pattern matching constructs. For example, in match x { A =&gt; 1, B =&gt; 2 }, the expression x is the #scrutinee .</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr_closure]]</p>
<p>[[rd_closure]]</p>
<p>[[pnkfx_closure]]</p>
<p>[[er_closure]]</p>
<hr />
<h2 id="closure-vs-function"><a class="header" href="#closure-vs-function">Closure Vs Function</a></h2>
<p>what sets them apart from functions is that they are also <strong>aware of the environment</strong> they are declared within and can reference any variable from their environment. The way they reference variables from their environment is determined by how the variable is used inside the closure.</p>
<h2 id="closure"><a class="header" href="#closure">Closure</a></h2>
<blockquote>
<p>Closure to code blocks that are <strong>encapsulated</strong> in Rust.</p>
</blockquote>
<blockquote>
<p>Closures are also known as anonymous functions and lambda functions. </p>
</blockquote>
<blockquote>
<p>(|…|) followed by curly brackets ({…}). The pair of vertical bars lets you define arguments. Lambda functions in </p>
</blockquote>
<blockquote>
<p>Rust can read variables from within their scope. These are closures.</p>
</blockquote>
<blockquote>
<p>Unlike regular functions, lambda functions cannot be defined in global scope(out of main).</p>
</blockquote>
<p>A closure, by default, will try to <strong>capture</strong> the variable in the most flexible way possible. Only when the programmer needs a certain way of capturing the value will they coerce to the programmer’s intent. That won’t make much sense unless we see different kinds of closures in action. <em>Closures under the hood are anonymous structs that implement three traits(Fn, FnOnce, FnMut)</em> that represent how closures access their environment. We will look at the three traits (ordered from least restrictive to most restrictive) next.</p>
<h3 id="fn"><a class="header" href="#fn">Fn</a></h3>
<p>Closures that <strong>access variables only for read access</strong> implement the Fn trait. Any value they access are as reference types (&amp;T). This is the default mode of borrowing the closures assumes.</p>
<h3 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h3>
<p>Closures that take ownership of the data they read from their environment get implemented with FnOnce. The name signifies that this closure can only be called once and, because of that, the variables are available only once. This is the least recommended way to construct and use closures, because <strong>you cannot use the referenced variables later</strong></p>
<h3 id="fnmut"><a class="header" href="#fnmut">FnMut</a></h3>
<p>When the compiler figures out that a closure <strong>mutates a value referenced from the environment</strong>, the closure implements the FnMut trait.</p>
<h2 id="returning-closures"><a class="header" href="#returning-closures">Returning Closures</a></h2>
<p>you’re not allowed to use the function pointer fn as a return type, for example.
The following code tries to return a closure directly, but it won’t compile:</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {//error doesn't have a size known at compile-time
    |x| x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>The error references the Sized trait again! Rust doesn’t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="some-references"><a class="header" href="#some-references">Some references</a></h2>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">Finding-closure-in-rust</a></p>
<h2 id="glossery-7"><a class="header" href="#glossery-7">Glossery</a></h2>
<blockquote>
<p><code>closure</code>:	&lt;&gt;  , || {}   , Closures are represented by traits, so they cannot be a return type, let consume_and_return_x = move || x;</p>
</blockquote>
<blockquote>
<p><code>tags</code> </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[rd_function]]</p>
<p>[[re_function]]</p>
<hr />
<h2 id="const-function"><a class="header" href="#const-function">Const function</a></h2>
<p>This means that they <strong>cannot take mutable</strong> arguments to any type. They also <strong>cannot</strong> include operations that are dynamic such as a <strong>heap</strong> allocation.they are evaluated at <strong>compile time</strong>.</p>
<blockquote>
<p>The following code demonstrates how we can do this entirely at runtime.using the include_bytes! macro, which also reads the file at compile time.Without the const function, all this would be done at runtime:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">const fn read_header(a: &amp;[u8]) -&gt; (u8, u8, u8, u8) {
    (a[0], a[1], a[2], a[3])
}

const FILE_HEADER: (u8,u8,u8,u8) = read_header(include_bytes!(&quot;./const_fn_file.rs&quot;));

fn main() {
    println!(&quot;{:?}&quot;, FILE_HEADER);
}
</code></pre></pre>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h2>
<p>Unlike closures, <strong>fn is a type</strong> rather than a trait, so we specify fn as the parameter type directly rather than declaring a generic type parameter with one of the Fn traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (Fn, FnMut, and FnOnce), meaning you can always pass a function pointer as an argument for a function that expects a closure. <em>It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</em></p>
<p>That said, one example of where you would want to only accept fn and not closures is when interfacing with external code that doesn’t have closures: C functions can accept functions as arguments, but <em>C doesn’t have closures</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p>As an example of where you could use either a closure defined inline or a named function, let’s look at a use of the map method provided by the Iterator trait in the standard library. To use the map function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Or we could name a function as the argument to map instead of the closure, like this:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();

<span class="boring">}
</span></code></pre></pre>
<h2 id="glossery-8"><a class="header" href="#glossery-8">Glossery</a></h2>
<blockquote>
<p><code>closure</code>:	&lt;&gt;  , || {}   , Closures are represented by traits, so they cannot be a return type, let consume_and_return_x = move || x;</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[file]] [[compile_time]] [[runtime]] [[const]] [[macro]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr_lazy]]</p>
<p>[[rd_lazy]]</p>
<hr />
<h2 id="dynamic-static"><a class="header" href="#dynamic-static">Dynamic Static</a></h2>
<p>For example, you can’t create a HashMap as a static value because it requires a heap allocation. Fortunately, we can have HashMap and other dynamic collection types such as Vec as global statics too, using a third-party crate called lazy_static. This crate exposes the lazy_static! macro, which can be used to initialize any dynamic type that’s accessible globally from anywhere in the program. Here’s a snippet of how to initialize a Vec that can be mutated from multiple threads(Items declared within the lazy_static! macro are required to implement the Sync trait):</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;
lazy_static! {
    static ref ITEMS: Mutex&lt;Vec&lt;u64&gt;&gt; = {
        let mut v = vec![];
        v.push(9);
        v.push(2);
        v.push(1);
        Mutex::new(v)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Items declared within the lazy_static! macro are required to implement the Sync trait. This means if we want a mutable static, we have to use a multithreaded type such as Mutex or RwLock instead of  RefCell.</p>
</blockquote>
<h2 id="memorization-lazy-evaluation"><a class="header" href="#memorization-lazy-evaluation">Memorization-Lazy-Evaluation</a></h2>
<blockquote>
<p>We can create a struct that will hold the closure and the resulting value of calling the closure.The struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn’t have to be responsible for saving and reusing the result. You may know this pattern as memoization or lazy evaluation.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fn=|num| -&gt; {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="convert-to-memoization-or-lazy-evaluation"><a class="header" href="#convert-to-memoization-or-lazy-evaluation">Convert to memoization or lazy evaluation</a></h3>
<blockquote>
<p>Fn, FnMut, or FnOnce. We’ll discuss the difference between these traits in the “Capturing the Environment with Closures”</p>
</blockquote>
<ul>
<li>FnOnce consumes the variables it captures from its enclosing scope, known as the closure’s environment. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined.</li>
</ul>
<blockquote>
<p>The Once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</p>
</blockquote>
<ul>
<li>
<p>FnMut can change the environment because it mutably borrows values.</p>
</li>
<li>
<p>Fn borrows values from the environment immutably.</p>
</li>
<li>
<p>FnOnce: takes the whole value</p>
</li>
<li>
<p>FnMut: takes a mutable reference</p>
</li>
<li>
<p>Fn: takes a regular reference </p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}


<span class="boring">}
</span></code></pre></pre>
<hr />
<blockquote>
<p><code>tags</code> [[memorization]] [[cache]] [[memory]] [[FnOnce]] [[FnMut]] [[Fn]] [[evaluation]] [[macro]] [[static]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>[[ria-network]]</p>
<hr />
<p><img src="network/../../rust/assets/images/network-layer.jpg" alt="Network-layer" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>[[DESIGN_PATTERN]]</p>
<hr />
<p><em>Using the <strong>state pattern</strong> means when the business requirements of the program change</em>, we won’t need to change the code of the value holding the state or the code that uses the value. We’ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects.
e.g Post type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in—draft, waiting for review, or published. Changing from one state to another will be managed internally within the Post type. The states change in response to the methods called by our library’s users on the Post instance, but they don’t have to manage the state changes directly. Also, users can’t make a mistake with the states, like publishing a post before it’s reviewed.</p>
<p>In a struct or enum, the data in the struct fields and the behavior in impl blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object.
However, trait objects are more like objects in other languages in the sense that they combine data and behavior</p>
<hr />
<blockquote>
<p><code>tags</code> [[pattern_state]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>objects allow Rust programmers to mimic some features of dynamic languages by allowing multiple types to be wedged into the same container.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[STRUCTURAL]]</p>
<p>[[CREATIONAL]]</p>
<p>[[BEHAVIOARAL]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[lpxxn/lpxxn-behavioral]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[STATE_PATTERN]]</p>
<p>[[PROCESS]]</p>
<p>[[lpxxn-behavioral]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[re-behavioral-process]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[lpxxn-creational]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[lpxxn-structural]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ASSOCIATE]]</p>
<p>[[INHERITANCE]]</p>
<p>[[SHARED_BEHAVIOR]]</p>
<p>[[SAFEOBJECT]]</p>
<p>[[NONE_OBJECT_SAFE]]</p>
<p>[[BUILT_IN]]</p>
<p>[[BUILTIN-TRAIT]]</p>
<hr />
<blockquote>
<p>We can use <strong>traits</strong> to define <strong>shared behavior</strong> in an <strong>abstract</strong> way. We can use <strong>trait bounds</strong> to specify that a <strong>generic type</strong> can be any type that has certain behavior.</p>
</blockquote>
<blockquote>
<p>Traits are similar to a feature often called interfaces in other languages, although with some differences.</p>
</blockquote>
<blockquote>
<p>What is a trait? A trait is a language feature that is analogous to an <strong>interface, protocol, or contract.</strong> If you have a background in object-oriented programming, consider a trait to be an abstract base class. If you have a background in functional programming, Rust’s traits are close to Haskell’s type classes.</p>
</blockquote>
<blockquote>
<p>these also <strong>support a form of inheritance</strong> that’s common in most object oriented languages. For now, though, the thing to remember is that traits represent common behavior (Or <strong>reusable</strong> codes like println!)that types opt into via the syntax impl Trait for Type.</p>
</blockquote>
<blockquote>
<p>Traits are <strong>private</strong> by default.</p>
</blockquote>
<blockquote>
<p>Traits are not usable by themselves and are meant to be implemented by types. Traits have the power to establish <strong>relationships between distinct types</strong>. 
They are the <strong>backbone</strong> to many language features such as closures, operators, smart pointers, loops, compile-time [[data_race]] checks, and much more.</p>
</blockquote>
<blockquote>
<p>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon</p>
</blockquote>
<blockquote>
<p>This interface consists of associated items, which come in three varieties:</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Functions</li>
<li><input disabled="" type="checkbox" checked=""/>
Types</li>
<li><input disabled="" type="checkbox" checked=""/>
Constants</li>
</ul>
<blockquote>
<p>What does [[PartialEq]] do for types? It enables comparisons with the == operator. “Partial” allows for cases where two values that match exactly should not be treated as equal, such as the floating point’s NAN value or SQL’s NULL.  When you see a sentence with the following structure, “…T <strong>is</strong> Debug…”, what they’re saying is that T <strong>implements</strong> the Debug trait.</p>
</blockquote>
<blockquote>
<p><strong>All traits define an implicit type parameter Self</strong> that refers to “the type that is implementing this interface”</p>
</blockquote>
<blockquote>
<p>Trait functions may omit the function body by replacing it with a semicolon. This indicates that the implementation must define the function. If the trait function defines a body, this definition acts as a default for any implementation which does not override it. Similarly, <strong>associated constants</strong> may omit the equals sign and expression to <strong>indicate implementations</strong> must define the constant value. <strong>Associated types</strong> must never define the type, the type may only be <strong>specified in an implementation.</strong></p>
</blockquote>
<blockquote>
<p>we mentioned that to use traits as <strong>trait objects</strong>, we must <strong>put them behind a pointer</strong>, such as <strong>&amp;dyn Trait or Box<dyn Trait></strong> (Rc<dyn Trait> would work too).</p>
</blockquote>
<h2 id="why-we-need-traits"><a class="header" href="#why-we-need-traits">Why we need traits?</a></h2>
<blockquote>
<p>Example:</p>
</blockquote>
<pre><code class="language-rust no_run compile_fail ignore">impl i32 {
    fn double(&amp;self) -&gt; Self {
        self * 2
    }
}

impl i64 {
    fn double(&amp;self) -&gt; Self {
        self * 2
    }
}

fn main() {
    println!(&quot;double 5_i32 == {}&quot;, 5_i32.double());
    println!(&quot;double 5_i64 == {}&quot;, 5_i64.double());
}
</code></pre>
<blockquote>
<p>Result:</p>
</blockquote>
<pre><code class="language-no_run compile_fail ignore">error[E0390]: only a single inherent implementation marked with `#[lang = &quot;i32&quot;]` is allowed for the `i32` primitive
</code></pre>
<p>NOTE: You may be wondering, why this limitation? We won’t get into these kinds of “why” questions here, but at the time of writing, there is <a href="https://github.com/Ixrec/rust-orphan-rules">some material online</a> you can read regarding this if you’re curious. #orphan_rules</p>
<blockquote>
<p>Answer:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">trait Double {
    fn double(&amp;self) -&gt; Self;//-&gt; i32  is wrong
}

impl Double for i32 {
    fn double(&amp;self) -&gt; Self { // or i32
        self * 2
    }
}

impl Double for i64 {
    fn double(&amp;self) -&gt; Self { // or i32
        self * 2
    }
}

fn main() {
    println!(&quot;double 5_i32 == {}&quot;, 5_i32.double());
    println!(&quot;double 5_i64 == {}&quot;, 5_i64.double());
}
</code></pre></pre>
<h2 id="blanket-trait"><a class="header" href="#blanket-trait">Blanket Trait</a></h2>
<p><code>Blanket implementation</code>:</p>
<blockquote>
<p>Any implementation where a type appears uncovered. impl<T> Foo for T, impl<T> Bar<T> for T, impl<T> Bar&lt;Vec<T>&gt; for T, and impl<T> Bar<T> for Vec<T> are considered blanket impls. However, impl<T> Bar&lt;Vec<T>&gt; for Vec<T> is not a blanket impl, as all instances of T which appear in this impl are covered by Vec.</p>
</blockquote>
<p><code>Bound</code>:
Bounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.</p>
<p>Trait bounds allow us to specify that a generic function should accept any type that implements a particular trait. In doing so, we focus on the expected behavior of the type rather than its concrete identity. This approach enhances code flexibility and reusability, as functions become adaptable to different data structures that adhere to the same interface.</p>
<p>Trait bounds are pivotal in creating functions and structures that accommodate diverse types, minimizing redundancy and ensuring code safety.</p>
<p>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called blanket implementations and are extensively used in the Rust standard library. For example, the standard library implements the ToString trait on any type that implements the Display trait. The impl block in the standard library looks similar to this code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Because the standard library has this blanket implementation, we can call the to_string method defined by the ToString trait on any type that implements the Display trait. For example, we can turn integers into their corresponding String values like this because integers implement Display:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Blanket implementations appear in the documentation for the trait in the “Implementors” section.</p>
</blockquote>
<hr />
<h2 id="universal-function-call-syntax"><a class="header" href="#universal-function-call-syntax">Universal function call syntax</a></h2>
<p><em>Inherent methods on types are given higher priority than other methods with the same name</em>. To call a trait method, we can use the Universal Function Call Syntax (<strong>UFCS</strong>).</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Driver {
    fn drive(&amp;self) {
        println!(&quot;Driver's driving!&quot;);
    }
}

struct MyCar;

impl MyCar {
    fn drive(&amp;self) {
        println!(&quot;I'm driving!&quot;);
    }
}

impl Driver for MyCar {}

fn main() {
    let car = MyCar;
    car.drive();
}
</code></pre></pre>
<h2 id="where"><a class="header" href="#where">Where</a></h2>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {}

pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {}

pub fn notify(item: &amp;(impl Summary + Display)) {}

pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}

pub fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>We can use a where clause, like this:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>This function’s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</p>
</blockquote>
<hr />
<h2 id="generic-implementation"><a class="header" href="#generic-implementation">Generic Implementation</a></h2>
<h3 id="constraits"><a class="header" href="#constraits">Constraits</a></h3>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait{}
trait GenericTrait&lt;T&gt; {}
trait HasAssocType { type Ty; }
struct Struct;
struct GenericStruct&lt;T&gt;(T);
struct ConstGenericStruct&lt;const N: usize&gt;([(); N]);
// T constrains by being an argument to GenericTrait.
impl&lt;T&gt; GenericTrait&lt;T&gt; for i32 { /* ... */ }

// T constrains by being an arguement to GenericStruct
impl&lt;T&gt; Trait for GenericStruct&lt;T&gt; { /* ... */ }

// Likewise, N constrains by being an argument to ConstGenericStruct
impl&lt;const N: usize&gt; Trait for ConstGenericStruct&lt;N&gt; { /* ... */ }

// T constrains by being in an associated type in a bound for type `U` which is
// itself a generic parameter constraining the trait.
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// Like previous, except the type is `(U, isize)`. `U` appears inside the type
// that includes `T`, and is not the type itself.
impl&lt;T, U&gt; GenericStruct&lt;U&gt; where (U, isize): HasAssocType&lt;Ty = T&gt; { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<h3 id="non-constraits"><a class="header" href="#non-constraits">Non-Constraits</a></h3>
<p>The rest of these are errors, since they have type or const parameters that do not constrain.
<code>T</code> does not constrain since it does not appear at all.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Struct { /* ... */ }
// N does not constrain for the same reason.
impl&lt;const N: usize&gt; Struct { /* ... */ }
// Usage of T inside the implementation does not constrain the impl.
impl&lt;T&gt; Struct {
    fn uses_t(t: &amp;T) { /* ... */ }
}
// T is used as an associated type in the bounds for U, but U does not constrain.
impl&lt;T, U&gt; Struct where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }
// T is used in the bounds, but not as an associated type, so it does not constrain.
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: GenericTrait&lt;T&gt; {}
/* 
Example of an allowed unconstraining lifetime parameter:
*/
impl&lt;'a&gt; Struct {}
/* 
Example of a disallowed unconstraining lifetime parameter:
*/
impl&lt;'a&gt; HasAssocType for Struct {
    type Ty = &amp;'a Struct;
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use-cases</a></h2>
<p>We’ve seen a lot of the mechanics and basic use of traits above, but they also wind up playing a few other important roles in Rust: </p>
<p><code>Closures</code>:</p>
<blockquote>
<p>Somewhat like the <strong>ClickCallback trait</strong>, closures in Rust are simply particular traits.</p>
</blockquote>
<p><code>Conditional APIs</code>:</p>
<blockquote>
<p>Generics make it possible to implement a trait conditionally:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Pair&lt;A, B&gt; { first: A, second: B }
    impl&lt;A: Hash, B: Hash&gt; Hash for Pair&lt;A, B&gt; {
        fn hash(&amp;self) -&gt; u64 {
            self.first.hash() ^ self.second.hash()
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Here, the Pair type implements Hash if, and only if, its components do – allowing the single Pair type to be used in different contexts, while supporting the largest API available for each context. It’s such a common pattern in Rust that there is built-in support for generating certain kinds of “mechanical” implementations automatically:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Hash)]
    struct Pair&lt;A, B&gt; { .. }
<span class="boring">}
</span></code></pre></pre>
<p><code>Extension methods</code>:</p>
<blockquote>
<p>Traits can be used to extend an existing type (defined elsewhere) with new methods, for convenience, similarly to C#’s extension methods. This falls directly out of the scoping rules for traits: you just define the new methods in a trait, provide an implementation for the type in question, and voila, the method is available.</p>
</blockquote>
<p><code>Markers</code>:</p>
<blockquote>
<p>Rust has a handful of “markers” that classify types: Send, Sync, Copy, Sized. These markers are just traits with empty bodies, which can then be used in both generics and trait objects. Markers can be defined in libraries, and they automatically provide #[derive]-style implementations: if all of a types components are Send, for example, so is the type. As we saw before, these markers can be very powerful: the Send marker is how Rust guarantees thread safety.</p>
</blockquote>
<p><code>Overloading</code>:</p>
<blockquote>
<p>Rust does not support traditional overloading where the same method is defined with multiple signatures. But traits provide much of the benefit of overloading: if a method is defined generically over a trait, it can be called with any type implementing that trait. Compared to traditional overloading, this has two advantages. First, it means the overloading is less ad hoc: once you understand a trait, you immediately understand the overloading pattern of any APIs using it. Second, it is extensible: you can effectively provide new overloads downstream from a method by providing new trait implementations.</p>
</blockquote>
<p><code>Operators</code></p>
<blockquote>
<p>Rust allows you to overload operators like <code>+</code> on your own types. Each of the operators is defined by a corresponding standard library trait, and any type implementing the trait automatically provides the operator as well.</p>
</blockquote>
<p><code>The point(note)</code>:</p>
<blockquote>
<p>despite their seeming simplicity, traits are a unifying concept that supports a wide range of use cases and patterns, without having to pile on additional language features.</p>
</blockquote>
<h2 id="special-traits"><a class="header" href="#special-traits">Special Traits</a></h2>
<p><a href="https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#special-types-and-traits">Special Traits&amp;Types</a></p>
<h2 id="glossery-9"><a class="header" href="#glossery-9">Glossery</a></h2>
<blockquote>
<p><code>Local trait</code>: A trait which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given trait Foo&lt;T, U&gt;, Foo is always local, regardless of the types substituted for T and U.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trait-methods"><a class="header" href="#trait-methods">Trait Methods</a></h2>
<blockquote>
<p>We can have two kinds of methods within a trait: Associated methods, Instance methods</p>
</blockquote>
<h3 id="associated-methods"><a class="header" href="#associated-methods">Associated methods</a></h3>
<blockquote>
<p><strong>Associated types might seem like a similar concept to generics.</strong></p>
</blockquote>
<p><em>Associated types connect a</em> <strong>type placeholder</strong> <em>with a trait such that the trait method definitions can use these placeholder types in their signatures.</em> The implementor of a trait will specify the concrete type to be used instead of the placeholder type for the particular implementation. That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.</p>
<p>One example of a trait with an associated type is the Iterator trait that the standard library provides. The associated type is named Item and stands in for the type of the values the type implementing the Iterator trait is iterating over. </p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
       unimplemnted!();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>eq:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h3>
<blockquote>
<p>These are <strong>methods that have their first parameter as self</strong>. These are only available on instances of the type that are implementing the trait.  self points to the instance of the type implementing the trait. 
It can be of three types:</p>
</blockquote>
<blockquote>
<p><strong>self  methods</strong>, which <em>consume the instance</em> when called; </p>
</blockquote>
<blockquote>
<p><strong>&amp;self methods</strong>, which only have <em>read access</em> to the instance its members (if any); and </p>
</blockquote>
<blockquote>
<p><strong>&amp;mut self methods</strong>, which have <em>mutable access</em> to its members and can modify them or even replace them with another instance. </p>
</blockquote>
<blockquote>
<p><strong>For example, the as_ref method from the AsRef trait</strong> in the standard library <strong>is an instance method</strong> that takes &amp;self, and is meant to be implemented by types that can be converted to a reference or a pointer.</p>
</blockquote>
<h3 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h3>
<blockquote>
<p>These are methods that are <strong>available directly on the type</strong> implementing the trait and <strong>do not need an instance of the type</strong> to invoke them. There are also known <strong>as static methods</strong> in mainstream languages, <strong>for example, the from_str method from the FromStr trait</strong> in the standard library. <em>It is implemented</em> for a String and thus allows you to create a String from a &amp;str by calling String::from_str(“foo”).</p>
</blockquote>
<h2 id="associated-type-traits"><a class="header" href="#associated-type-traits">Associated type traits</a></h2>
<blockquote>
<p>Associated types appear quite a bit in the Rust standard library. They are part of the arithmetic <strong>operations</strong> like + and *. They play a big role in the Iterator trait.
The advantage of them is that, in the implementation, they allow us to declare the assciated type once and use <strong>Self::Out as the return type</strong> or parameter type in any of the trait methods or functions.</p>
</blockquote>
<blockquote>
<p>We have <strong>two kind of asscociate type</strong> for purpose:</p>
</blockquote>
<blockquote>
<p><strong>output and constraints associated type (Ty = T).</strong></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Out;
    fn get_value(self) -&gt; Self::Out;
}

<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>For Example:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
//-This syntax seems comparable to that of generics. 
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A hypothetical definition of the Iterator trait using generics.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>With associated types</strong>, we don’t need to annotate types because we can’t implement a trait on a type multiple times.  At the First Example with the definition that uses associated types, we can only <strong>choose what the type of Item will be once</strong>, because there can only be one impl Iterator for Counter. </p>
</blockquote>
<blockquote>
<p>We don’t have to specify that we want an iterator of u32 values everywhere that we call next on Counter.</p>
</blockquote>
<blockquote>
<p>This removes the redundant specification of types, as is the case with generic traits. One of the finest examples of associated type traits is the Iterator trait.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: HasAssocType&lt;Ty = T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The syntax for specifying a <strong>default type for a generic type</strong> is &lt;PlaceholderType=ConcreteType&gt; when declaring the generic type.</p>
</blockquote>
<blockquote>
<p><code>T</code> “constrains” by being in an “associated type(Ty = T)” in a bound for type <code>U</code> which is itself <em>a generic parameter(GenericTrait)</em> constraining the trait.</p>
</blockquote>
<blockquote>
<p>For example:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// we do not need to write trait Add due to is built-in trait
 pub trait Add&lt;RHS = Self&gt; {
     type Output;
     fn add(self, rhs: RHS) -&gt; Self::Output;
 }

impl&lt;T: Add&lt;T, Output=T&gt;&gt; Add for Complex&lt;T&gt; {
    type Output = Complex&lt;T&gt;;
    fn add(self, rhs: Complex&lt;T&gt;) -&gt; Self::Output {
        Complex { re: self.re + rhs.re, im: self.im + rhs.im }
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Next Example:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">trait AssociatedType {
    // Associated type declaration
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // Associated type definition
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // Usage of the associated type to refer to OtherStruct as &lt;Struct as AssociatedType&gt;::Assoc
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}
</code></pre></pre>
<h2 id="associated-types-container-example"><a class="header" href="#associated-types-container-example">Associated Types Container Example</a></h2>
<p>Consider the following example of a Container trait. Notice that the type is available for use in the method signatures:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
<span class="boring">}
</span></code></pre></pre>
<p>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type E. Here’s an implementation of Container for the standard library type Vec:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Relationship between Bounds and WhereBounds</p>
</blockquote>
<blockquote>
<p>In this example:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Example {
    type Output&lt;T&gt;: Ord where T: Debug;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Given a reference to the associated type like <X as Example>::Output<Y>, the associated type itself must be Ord, and the type Y must be Debug.</p>
</blockquote>
<h2 id="glossery-10"><a class="header" href="#glossery-10">Glossery</a></h2>
<blockquote>
<p><code>The associated type = placeholder type</code> :  is named Item’pub trait Iterator {type Item;}’</p>
</blockquote>
<blockquote>
<p>Another example is ‘HasAssocType&lt;Ty = T&gt;’</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[associate_method]] [[instance_method]] [[associate_trait]] [[rhs]]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trait-inheritance"><a class="header" href="#trait-inheritance">Trait Inheritance</a></h2>
<blockquote>
<p>Traits can also specify in their declaration that they depend on other traits; this is a feature known as trait inheritance.
One such example from the standard library is the <strong>Copy trait, which requires  the type to also implement the Clone trait.</strong></p>
</blockquote>
<blockquote>
<p><code>tags</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria_trait_display]]</p>
<p>[[edu-partial-eq-trait]]</p>
<p>[[other-partialeq]]</p>
<hr />
<h1 id="marker-traits"><a class="header" href="#marker-traits">Marker Traits</a></h1>
<h2 id="size"><a class="header" href="#size">?Size</a></h2>
<blockquote>
<p>Sized trait is a <strong>marker trait</strong> that represents types whose <strong>sizes are known at compile time</strong>. It is implemented for most types in Rust <strong>except for #unsized_types</strong>. All type parameters have an implicit trait bound of Sized in their definition. </p>
</blockquote>
<blockquote>
<p>We can also specify <strong>optional trait bounds using the ?</strong> operator before a trait, but the ? operator with traits <strong>only works for marker traits</strong> as the time of writing this book. It may be extended to other types in future.</p>
</blockquote>
<h2 id="borrow--asref"><a class="header" href="#borrow--asref">Borrow &amp; AsRef</a></h2>
<p>These are special traits that carry the notion of able to construct a out of any type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::borrow::Borrow;
fn main() {
    let s = &quot;hello&quot;;
    let t: &amp;str = s.borrow();
    println!(&quot;{}&quot;, t); // Prints &quot;hello&quot;
}
</code></pre></pre>
<h2 id="to-owned"><a class="header" href="#to-owned">To Owned</a></h2>
<p>This trait is meant to be implemented for types that can be converted in to an owned version. For example, the &amp;str type has this trait implemented for String. This means the <strong>&amp;str type has a method called to_owned() on it that can convert it in to a String type</strong>, which is an owned type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::convert::AsRef;

fn print_length&lt;T: AsRef&lt;[u8]&gt;&gt;(data: T) {
    println!(&quot;Length: {}&quot;, data.as_ref().len());
}

fn main() {
    let my_string = &quot;Hello, world!&quot;;
    print_length(my_string); // Uses AsRef to treat the string as a byte slice
}
</code></pre></pre>
<h2 id="from--into"><a class="header" href="#from--into">From &amp; Into</a></h2>
<blockquote>
<p>For obvious reasons, those traits cannot be auto-derived, but writing them should be trivial in most cases</p>
</blockquote>
<blockquote>
<p>To convert one type into another, we have the From and Into traits. The interesting part about both of these traits is that we only need to implement the From trait and we get the implementation of the Into trait for free, because of the following impl:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Why not implement From everywhere? The orphan rule unfortunately forbids implementing From for types not defined in other crates. For example, I have an Optioned<T> type, that I may want to convert into an Option<T>. Trying to implement From:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Noned + Copy&gt; From&lt;Optioned&lt;T&gt;&gt; for Option&lt;T&gt; {
    #[inline]
    fn from(self) -&gt; Option&lt;T&gt; { self.map_or_else(|| none(), wrap) }
}
<span class="boring">}
</span></code></pre></pre>
<p>I get an error: type parameter T must be used as the type parameter for some local type (e.g. MyStruct<T>); only traits defined in the current crate can be implemented for a type parameter [E0210]</p>
<p>Note that you can implement From and Into with multiple classes, you can have a From<Foo> and a From<Bar> for the same type.</p>
<p>There are a good number of traits starting with Into – IntoIterator, which is stable and which we already have discussed above, just being one of them. There also is FromIterator, which does the reverse, namely constructing a value of your type from an iterator of items.</p>
<p>Then there is FromStr for any types that can be parsed from a string, which is very useful for types that you want read from any textual source, e.g. configuration or user input. Note that its interface differs from From&lt;&amp;str&gt; in that it returns a Result, and thus allows to relate parsing errors to the caller.</p>
<h2 id="partial-eq"><a class="header" href="#partial-eq">Partial Eq</a></h2>
<blockquote>
<p>comparision like &lt;=&gt;=.</p>
</blockquote>
<blockquote>
<p><strong>f32/64</strong> types only implement the std::cmp::<strong>PartialEq</strong> trait, whereas <strong>other numeric</strong> types also implement std::cmp::<strong>Eq</strong></p>
</blockquote>
<h2 id="termination"><a class="header" href="#termination">Termination</a></h2>
<pre><code class="language-rust no_run compile_fail  ignore">    ()
    Result&lt;T, E&gt; where T: Termination, E: Debug
    !
</code></pre>
<blockquote>
<p>For Example:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">fn main() -&gt; impl std::process::Termination // () or !
{
    std::process::ExitCode::SUCCESS
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[TRAIT_BOUND]]</p>
<p>[[NONE_OBJECT_SAFE]]</p>
<p>[[AGGRIGATOR]]</p>
<p>[[BUILTIN-TRAIT]]</p>
<hr />
<h2 id="generic-traits"><a class="header" href="#generic-traits">Generic traits</a></h2>
<blockquote>
<p>Two such examples are is the <strong>From<T> and Into<T> traits</strong>, which allow from conversion from a type to a type T and vice versa.
generic traits can get quite <strong>verbose</strong> when they are declared with three or four generic types.</p>
</blockquote>
<pre><code class="language-rust compile_fail no_run ignore">pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
</code></pre>
<h2 id="orphan-rule-coherence"><a class="header" href="#orphan-rule-coherence">Orphan Rule-Coherence</a></h2>
<blockquote>
<p>The idea of trait coherence is that there <strong>should be exactly one implementation of a trait on a type that implements it</strong>. This should be quite obvious since, with two implementations there would be ambiguity in what to choose between the two.</p>
</blockquote>
<blockquote>
<p>Another rule that might confuse many about traits is the orphan rule. The orphan rule, in simple words, <strong>states that we cannot implement external traits on external types.</strong>
To word it in another way, <em>either the trait must be defined by you</em> if you are implementing something on an external type, or your type should be defined by you when you are implementing an external trait. This rules out the possibility of having conflicts in overlapping trait implementations across crates.</p>
</blockquote>
<h2 id="glossery-11"><a class="header" href="#glossery-11">Glossery</a></h2>
<blockquote>
<p><code>fully qualified syntax</code> : <Type as Trait>::function(receiver_if_method, next_arg, …);</p>
</blockquote>
<blockquote>
<p><code>bound</code>  : ‘where Self: Sized’</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[orphan_rule]] [[coherence]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-trait"><a class="header" href="#builtin-trait">BUILTIN-TRAIT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>[[TRAITOBJECT]]</p>
<p>[[NON_DISPATCHABLE]]</p>
<hr />
<blockquote>
<p>Object safe traits can be the <strong>base trait of</strong> a trait object. A trait is object safe if it has the following qualities (defined in RFC 255):</p>
</blockquote>
<blockquote>
<p>All <strong>supertraits</strong> must also be object safe.</p>
</blockquote>
<blockquote>
<p>Sized must not be a supertrait. In other words, it must <strong>not require Self: Sized.</strong></p>
</blockquote>
<blockquote>
<p>It must <strong>not have any associated constants.</strong></p>
</blockquote>
<blockquote>
<p>All associated functions must either be <strong>dispatchable</strong> from a trait object or be explicitly <strong>non-dispatchable</strong> <em>(means cannot call method or func).</em></p>
</blockquote>
<h2 id="functionality"><a class="header" href="#functionality">Functionality</a></h2>
<h3 id="dispatchable-functions-require"><a class="header" href="#dispatchable-functions-require">Dispatchable functions require</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Not have any type parameters</strong> (although lifetime parameters are allowed).</li>
<li><input disabled="" type="checkbox" checked=""/>
be <strong>a method that does not use Self except in the type of the receiver.</strong></li>
</ul>
<h3 id="have-a-receiver-with-one-of-the-following-types"><a class="header" href="#have-a-receiver-with-one-of-the-following-types">Have a receiver with one of the following types</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>&amp;Self (i.e. &amp;self)</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>&amp;mut Self (i.e &amp;mut self)</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Box&lt;Self&gt;</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Rc&lt;Self&gt;</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Arc&lt;Self&gt;</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Pin&lt;P&gt; where P is one of the types above</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Does not have a where Self: Sized bound</strong> (receiver type of Self (i.e. self) implies this).</li>
</ul>
<blockquote>
<p>Explicitly non-dispatchable functions require:</p>
</blockquote>
<blockquote>
<p><strong>Have a where Self</strong>: Sized bound (receiver type of Self (i.e. self) implies this).</p>
</blockquote>
<blockquote>
<p><strong>Include the requirement that object-safe traits do not require Self:Sized</strong></p>
</blockquote>
<blockquote>
<p>And specify that methods may include where Self:Sized to overcome object safety restrictions.</p>
</blockquote>
<h1 id="object-safety"><a class="header" href="#object-safety">Object Safety</a></h1>
<p>Object safety is a set of rules and restrictions that does not allow trait objects to be constructed
<em>to convert any type into a trait object</em>, methods on the type need to be an instance—one that takes <strong>self</strong> by reference.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="dispatchable"><a class="header" href="#dispatchable">Dispatchable</a></h2>
<blockquote>
<p>Dispatch is the mechanism to determine <strong>which specific version of code is actually run when it involves polymorphism.</strong> </p>
</blockquote>
<blockquote>
<p>Two major forms of dispatch are <strong>static dispatch and dynamic dispatch</strong>. While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects’.</p>
</blockquote>
<blockquote>
<p>The code that results from <strong>monomorphization (early binding)</strong> is doing [[static_dispatch]], which is when the compiler knows what method you’re calling at compile time. This is opposed to dynamic dispatch, which is when the compiler can’t tell at compile time which method you’re calling.</p>
</blockquote>
<blockquote>
<p>Process of method resolution in a <strong>polymorphic(late binding)</strong> context is called dispatch.</p>
</blockquote>
<blockquote>
<p><strong>Invoking the method is called dispatching</strong>. In mainstream languages that support polymorphism, the dispatch may happen in either of the following ways:</p>
</blockquote>
<h3 id="static-dispatch"><a class="header" href="#static-dispatch">Static Dispatch</a></h3>
<blockquote>
<p>When the <strong>method to invoke is decided at compile time</strong>, it is known as [[static_dispatch]] or early binding. The method’s signature is used to decide the method to call, and all of this is decided at compile time. In Rust, <strong>generics exhibit</strong> this form of dispatch because even though the generic function can accept many arguments, a specialized <strong>copy</strong> of the function is generated at compile time with that concrete type.</p>
</blockquote>
<blockquote>
<p>The compiler reads the values that have been used in Option<T> instances and identifies two kinds of Option<T>: one is i32 and the other is f64. As such, it expands the generic definition of Option<T> into Option_i32 and Option_f64, thereby replacing the generic definition with the specific ones.</p>
</blockquote>
<blockquote>
<p><em>The monomorphized</em> version of the code looks like the following. The generic Option<T> is <em>replaced</em> with the specific definitions created <em>by the compiler</em>:</p>
</blockquote>
<blockquote>
<p>Because Rust compiles generic code into code that specifies the type in each instance, we pay <strong>no runtime cost for using generics</strong>. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust’s generics extremely efficient at runtime.This is opposed to dynamic dispatch.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">let integer = Some(5);
let float = Some(5.0);

enum Option_i32 {
    Some(i32),
    None,
}
enum Option_f64 {
    Some(f64),
    None,
}
fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<h3 id="dynamic"><a class="header" href="#dynamic">Dynamic</a></h3>
<p>A dynamically sized type (DST) is a type without a statically known size or alignment.</p>
<blockquote>
<p>ref.to [[TRAITOBJECT]]</p>
</blockquote>
<h2 id="summery"><a class="header" href="#summery">Summery</a></h2>
<blockquote>
<p>Traits, along with generics, provide both kinds of code reuse, either through [[monomorphization]] (early binding) or through runtime polymorphism (late binding). </p>
</blockquote>
<blockquote>
<p>The decision on when to use which depends on the context and the needs of the application in question. Often, <strong>[[error]]</strong> types are taken toward the <strong>dynamic</strong> dispatch train as they are supposed to be code paths that <strong>rarely get executed</strong>. </p>
</blockquote>
<blockquote>
<p><strong>Monomorphization</strong> can be handy for <strong>small use cases</strong>, but the downside to it is that it introduces <strong>code bloat and duplication, which affects the cache line and increases binary size</strong>. </p>
</blockquote>
<blockquote>
<p>However, of these two options, <strong>static</strong> dispatch should be preferred unless there is a hard constraint on binary size.</p>
</blockquote>
<h2 id="glossery-12"><a class="header" href="#glossery-12">Glossery</a></h2>
<blockquote>
<p><code>receiver</code> : for  exampele of type of Self (i.e. self) implies this.</p>
</blockquote>
<blockquote>
<p>Object-safe traits = Dispatchable</p>
</blockquote>
<blockquote>
<p>Trait objects = Dynamic Dispatch = fat pointer == only be created as a reference == unsized type </p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[trait_objects]] #monomorphization [[polymorphic]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[dynamic dispatch]]</p>
<hr />
<blockquote>
<p>DST : In object-oriented languages, there are times when the method call can’t be decided until runtime. This is because the concrete type is hidden and only interface methods are available to call on the type. In Java, this is the case when a function has an argument, which is <strong>known as an interface</strong>. Such a scenario can only be handled by dynamic dispatch. </p>
</blockquote>
<blockquote>
<p>DST is a type without a statically known size or alignment.</p>
</blockquote>
<blockquote>
<p>In DST, <strong>the method is determined dynamically</strong> <em>by navigating through the list of implementations of the interface from</em> <strong>the vtable and invoking the method</strong>. 
<strong>The vtable is a list of function pointers</strong> that point to each type’s implemented method. This has a bit of <strong>overhead</strong> because of the extra pointer indirection in method invocation.</p>
</blockquote>
<blockquote>
<p>In DST cases, the compiler emits code that at runtime will figure out which method to call.
<strong>When we use trait objects, Rust must use DST</strong>.
The compiler doesn’t know all the types that might be used with the code that is using trait objects,so it doesn’t know which method implemented on which type to call. </p>
</blockquote>
<blockquote>
<p>Instead, at runtime, Rust uses the <strong>pointers inside the trait object</strong> to know which method to call. There is a runtime cost when this lookup happens that doesn’t occur with static dispatch.</p>
</blockquote>
<blockquote>
<p><strong>DST also prevents the compiler from choosing to inline a method’s code, which in turn prevents some optimizations.</strong></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A trait object is implemented as <strong>a fat pointer</strong> and is an <strong>unsized</strong> type, which means that they can only be used behind references (&amp;).</p>
</blockquote>
<blockquote>
<p>A trait object fat pointer has <strong>the first pointer pointing points to the actual data</strong> associated with the object while the <strong>second pointer to a virtual table (vtable)</strong></p>
</blockquote>
<blockquote>
<p>One of the use cases for trait objects is that they allow you to operate on a collection that can have multiple types, but with an extra pointer indirection at runtime.</p>
</blockquote>
<blockquote>
<p>A dyn Trait is an #unsized_type and can <strong>only be created as a reference.</strong></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shapes: Vec&lt;&amp;dyn Area&gt; = vec![&amp;Square(3f32), &amp;Rectangle(4f32, 2f32)];
<span class="boring">}
</span></code></pre></pre>
<p>The code that results from monomorphization is doing static dispatch, which is when the compiler knows what method you’re calling at compile time.
This is opposed to DST, which is when the compiler can’t tell at compile time which method you’re calling.
In DST cases, the compiler emits code that at runtime will figure out which method to call.
When we use trait objects, Rust must use DST. The compiler doesn’t know all the types that might be used with the code that is using trait objects,
so it doesn’t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn’t occur with static dispatch. DST also prevents the compiler from choosing to inline a method’s code, which in turn prevents some optimizations.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}

pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Examples of object safe methods:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
use std::rc::Rc;
use std::sync::Arc;
use std::pin::Pin;
trait TraitMethods {
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested_pin(self: Pin&lt;Arc&lt;Self&gt;&gt;) {}
}
struct S;
impl TraitMethods for S {}
let t: Box&lt;dyn TraitMethods&gt; = Box::new(S);
//t.callable since object safe dispatchable
}
</code></pre></pre>
<h2 id="glossery-13"><a class="header" href="#glossery-13">Glossery</a></h2>
<blockquote>
<p>Dynamic dispatch(DST)</p>
</blockquote>
<blockquote>
<p><em>Box&lt;&gt;, RC&lt;&gt;, Every trait is a dynamically sized type. Rust has a particular trait called the Sized trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time</em>. In addition, Rust implicitly adds a bound on Sized to every generic function. </p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[unsized]] [[dyn]] [[fat_pointer]] [[vtable]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Here is an example trait that is not object safe:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait {
    fn foo(&amp;self) -&gt; int { 
        //... 
    }
    // Object-safe methods may not return `Self`:
    fn new() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Splitting a trait:</p>
</blockquote>
<blockquote>
<p>One option is to split a trait into object-safe and non-object-safe parts. We hope that this will lead to better design. We are not sure how much code this will affect, it would be good to have data about this.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Object Safe Trait
trait SomeTrait {
    fn foo(&amp;self) -&gt; int { ... }
}
//Non Object Safe
trait SomeTraitCtor : SomeTrait {
    fn new() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Adding a where-clause:</p>
</blockquote>
<blockquote>
<p>Sometimes adding a second trait feels like overkill. In that case, it is often an option to simply add a where Self:Sized clause to the methods of the trait that would otherwise violate the object safety rule.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait {
    fn foo(&amp;self) -&gt; int { ... }
    
    fn new() -&gt; Self
        where Self : Sized; // this condition is new
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="aggregator"><a class="header" href="#aggregator">Aggregator</a></h2>
<blockquote>
<p>Other crates that depend on the aggregator crate can also bring the Summary trait into scope to implement Summary on their own types. One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.</p>
<blockquote>
<p>For example, <strong>we can implement standard library traits like Display on a custom type like Tweet as part of our aggregator crate functionality</strong>, because the type Tweet is local to our aggregator crate. We can also implement Summary on Vec<T> in our aggregator crate, because the trait Summary is local to our aggregator crate.
But <strong>we can’t implement external traits on external types</strong>. For example, we can’t implement the Display trait on Vec<T> within our aggregator crate, because Display and Vec<T> are both defined in the standard library and aren’t local to our aggregator crate. 
This restriction is part of a property called <strong>coherence</strong>, and more specifically the <strong>orphan rule</strong>, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. 
Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[operate]]</p>
<p>[[edu-trait-bound]]</p>
<p>[[ms-trait-bound]]</p>
<hr />
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait bounds</a></h2>
<blockquote>
<p>In the implementation of outline_print, we want to use the Display trait’s functionality. Therefore, we need to specify that the OutlinePrint trait will work only for types that also implement Display and provide the functionality that OutlinePrint needs. We can do that in the trait definition by specifying OutlinePrint: Display. </p>
</blockquote>
<blockquote>
<p>This technique is similar to adding a trait bound to the trait.
we can use the to_string function that is automatically implemented for any type that implements Display.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {  let output = self.to_string();}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
</blockquote>
<pre><code class="language-rust compile_fail no_run ignore">fn load&lt;T: Loadable&gt;(&amp;self, entity: T) { .. }
</code></pre>
<blockquote>
<p>Notice the : Loadable part. This is how we specify a trait bound. Trait bounds allow us to constrain the range of parameters that a generic API can accept. <em>Specifying a trait bound on a generic item is similar to how we specify types for variables,</em> but here the variable is the generic type T and the type is some trait, such as <strong>T: SomeTrait</strong>. </p>
</blockquote>
<blockquote>
<p>Trait bounds are almost <strong>always needed when defining generic functions</strong>. </p>
</blockquote>
<blockquote>
<p><em>If one defines a generic function that takes T without any trait bounds, we cannot call any of the methods since Rust does not know what implementation to use for the given methods.</em></p>
</blockquote>
<blockquote>
<p>The <strong>where</strong> clause decouples the trait bound from the function signature and makes it readable.</p>
</blockquote>
<blockquote>
<p>We can specify <strong>trait bounds on types</strong> too:</p>
</blockquote>
<pre><code class="language-rust compile_fail no_run ignore">struct Foo&lt;T: Display&gt; {..}
</code></pre>
<h3 id="trait-bounds-with-impl-trait-syntax"><a class="header" href="#trait-bounds-with-impl-trait-syntax">Trait bounds with impl trait syntax</a></h3>
<p>Instead of specifying T: Display, we directly use impl Display. This is the impl trait syntax. This provides advantages in cases where we want to <strong>return a complex or unrepresentable type, such as a closure</strong> from a function. Without this syntax, you had to return it by putting it behind a pointer using the Box smart pointer type, which involves heap allocation.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt::Display;

fn show_me(val: impl Display) {
    println!(&quot;{}&quot;, val);
}

fn main() {
    show_me(&quot;Trait bounds are awesome&quot;);
}
</code></pre></pre>
<blockquote>
<p>The impl trait syntax for trait bounds is mostly recommended to be used as return types from functions. Using it in parameter position means that we can’t use the turbofish operator. it should only be used when we don’t have a concrete type available to us, as is the case with closures.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt::Display;

fn surround_with_braces(val: impl Display) -&gt; impl Display {
    format!(&quot;{{{}}}&quot;, val)
}

fn main() {
    println!(&quot;{}&quot;, surround_with_braces(&quot;Hello&quot;));
}
</code></pre></pre>
<h2 id="why-we-need-trait-bound"><a class="header" href="#why-we-need-trait-bound">Why we need trait bound?</a></h2>
<blockquote>
<p>educative-rust-trait-ex-7.rs</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>We use generic type parameters, we can specify a <strong>default concrete type for the generic type</strong>. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default type when <strong>declaring a generic type with the &lt;PlaceholderType=ConcreteType&gt; syntax</strong>.
This code should look generally familiar: a trait with one method and an associated type. The new part is <strong>Rhs=Self: this syntax is called default type parameters</strong>. The Rhs generic type parameter (short for “right hand side”) defines the type of the rhs parameter in the add method. </p>
</blockquote>
<blockquote>
<p><em>If we don’t specify a concrete type for Rhs when we implement the Add trait, the type of Rhs will default to Self</em>, which will be the type we’re implementing Add on.</p>
</blockquote>
<blockquote>
<p>Rhs is a default to allow <strong>extension of the functionality</strong>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}
trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}

</code></pre></pre>
<blockquote>
<p>You’ll use default type parameters in two main ways:</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
To extend a type without breaking existing code</li>
<li><input disabled="" type="checkbox" checked=""/>
To allow customization in specific cases most users won’t need</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>tags</code>: [[rhs]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[WRAPPER]]</p>
<p>[[RHS]]</p>
<p>[[COMPUND]]</p>
<p>[[GENERIC]]</p>
<p>[[RETURN]]</p>
<p>[[STATIC]]</p>
<p>[[M_SCAL]]</p>
<p>[[VAR]]</p>
<hr />
<h2 id="glossery-14"><a class="header" href="#glossery-14">Glossery</a></h2>
<blockquote>
<p><code>Local type</code>: A struct, enum, or union which was defined in the current crate. This is not affected by applied type arguments. struct Foo is considered local, but Vec<Foo> is not. LocalType<ForeignType> is local. Type aliases do not affect locality.</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/nightly/reference/type-layout.html#type-layout">Type-Layout</a></p>
<blockquote>
<p><code>Nominal types</code>: Types that can be referred to by a path directly. Specifically enums, structs, unions, and trait objects.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>rust-in-action/ria-types-generic</p>
<p>rd-types-generic</p>
<p>rg-types-generic</p>
<p>pnkfx-types-generic</p>
<hr />
<p>Generics are part of the language design feature that enables code reuse and the Don’t repeat yourself (DRY) principle.</p>
<p>the case of statically typed programming languages. They first appeared in ML.</p>
<p>telling the compiler to fill in the actual types later when any code instantiates them.</p>
<p>Generic functions are a cheap way to give the illusion of polymorphic(late binding) code.</p>
<p>Note: By substitution, we mean that every time a generic item is used with a concrete type, a specialized copy of that code is generated at compile time with the type variable T, getting replaced with the concrete type. This process of generating specialized functions with concrete types at compile time is called monomorphization (is doing static_dispatch, early binding) , which is the procedure of doing the opposite of polymorphic functions.</p>
<p>generics is preferred in most cases because it has no runtime overhead, as is the case with trait objects.</p>
<p>we don’t need the &lt;Tafter impl because of the presence of u32 as a concrete type.</p>
<p>Let’s look at the case of instantiating Vec<T>, a generic type. Without any type signature, the following code does not compile:</p>
<pre><pre class="playground"><code class="language-rust comile_fail no_run edition2021">fn main() {
    let a = Vec::new();
}
</code></pre></pre>
<hr />
<p>You might be wondering whether there is a runtime cost when using generic type parameters. The good news is that using generic types won’t make your run any slower than it would with concrete types.</p>
<p>Rust accomplishes this by performing monomorphization of the code using generics at compile time. </p>
<p>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compile</p>
<p>Every programming language has tools for effectively handling the duplication of concepts.</p>
<p>In Rust, one such tool is generics. Generics are abstract stand-ins for concrete types or other properties. When we’re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.
The fragment &lt;T: std::ops::Add&lt;Output = T&gt;says that T must implement std::ops::Add. Using a single type variable T with the trait bound ensures that arguments i and j, as well as the result type, are the same type and that their type supports addition.</p>
<p><code>tags</code> pattern_new_type SAFEOBJECT</p>
<p>Glossery</p>
<p><code>Uncovered/Covered</code>: T is uncovered, but the T in Vec&lt;Tis covered</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[pb-return]]</p>
<p>[[re-return]]</p>
<hr />
<blockquote>
<p>The None variant is represented by a null pointer [[none]]</p>
</blockquote>
<blockquote>
<p>If you put a semicolon in the last expression, the block expressions default to a return value of the unit () type.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr-types-static]]</p>
<hr />
<blockquote>
<p>All access to a static is safe, but there are a number of restrictions on statics:</p>
</blockquote>
<ul>
<li>The type must have the Sync trait bound to allow thread-safe access.</li>
<li>Constants cannot refer to statics.</li>
</ul>
<blockquote>
<p>Statics are generally combined with synchronization primitives for any kind of thread-safe use. They are also used to implement <strong>global locks</strong> and when integrating with C libraries</p>
</blockquote>
<blockquote>
<p>Until now, we’ve not talked about global variables, which Rust does support but can be problematic with Rust’s ownership rules. <em>If two threads are accessing the same mutable global variable, it can cause a</em> [[data_race]].</p>
</blockquote>
<blockquote>
<p>’static lifetime, which means the Rust compiler can figure out the lifetime and we aren’t required to annotate it explicitly. Accessing an <strong>immutable</strong> static variable is <strong>safe</strong>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="newtype-pattern"><a class="header" href="#newtype-pattern">Newtype Pattern</a></h2>
<p>Using the Newtype Pattern to Implement External Traits on External Types
’ thin wrapper around the type’ : part of Vec<String> is noticed. struct Wrapper(Vec<String>); 
The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. Newtype is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and <strong>the wrapper type is elided at compile time.</strong></p>
<p>As an example, let’s say we want to implement Display on Vec<T>, which the <strong>orphan rule</strong> prevents us from doing directly because the Display trait and the Vec<T> type are defined outside our crate. We can make a Wrapper struct that holds an instance of Vec<T>; then we can implement Display on Wrapper and use the Vec<T> value</p>
<blockquote>
<p><code>Newtype pattern =  wrapper type = NewPattern = Thin Wrapper</code> :</p>
</blockquote>
<p>Thin wrapping of an existing type in another struct.we specify impl Add<Meters> to set the value of the Rhs type parameter instead of using the default of Self.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;
struct Millimeters(u32);
struct Meters(u32);
trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="wrapper-type-vs-deref-trait"><a class="header" href="#wrapper-type-vs-deref-trait">Wrapper Type Vs Deref Trait</a></h3>
<blockquote>
<p>The downside of using this technique is that #Wrapper is a new type, so it doesn’t have the methods of the value it’s holding. We would have to implement all the methods of Vec<T> directly on Wrapper such that the methods delegate to self.0, which would allow us to treat Wrapper exactly like a Vec<T>. <em>If we wanted the new type to have every method the inner type has, implementing the</em> #Deref trait.
If we don’t want the Wrapper type to have all the methods of the inner type—for example, to restrict the Wrapper type’s behavior—we would have to implement just the methods we do want manually.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<blockquote>
<p>use wrapper types, which allow more flexibility than what is available by default. These, however, incur costs at runtime to ensure that Rust’s safety guarantees are maintained. Another way to phrase this is that Rust allows programmers to opt in to garbage collection
To explain the wrapper type strategy, let’s introduce a wrapper type: std:rc::Rc. std:rc::Rc takes a type parameter T and is typically referred to as Rc<T>. Rc<T> reads as “R. C. of T” and stands for “a reference-counted value of type T.” Rc<T> provides shared ownership of T. Shared ownership prevents T from being removed from memory until every owner is removed.</p>
</blockquote>
<blockquote>
<p>As indicated by the name, reference counting is used to track valid references. As each reference is created, an internal counter increases by one. When a reference is dropped, the count decreases by one. When the count hits zero, T is also dropped.</p>
</blockquote>
<blockquote>
<p>Rc<T> implements Clone. Every call to base.clone() increments an internal counter. Every Drop decrements that counter. When the internal counter reaches zero, the original instance is freed.</p>
</blockquote>
<h2 id="glossery-15"><a class="header" href="#glossery-15">Glossery</a></h2>
<blockquote>
<p><code>Thin wrapper around the type</code> : part of Vec<String> is noticed. struct Wrapper(Vec<String>);</p>
</blockquote>
<blockquote>
<p><code>wrapper type</code> = reference-counted value = shared ownership = track valid references</p>
</blockquote>
<blockquote>
<p><code>tags</code> [[new_type]] [[orphan]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-types-rhs]</p>
<p>[[rd-types-rhs]</p>
<p>[[ria-types-rhs]</p>
<hr />
<h2 id="right-hand-side"><a class="header" href="#right-hand-side">Right Hand Side</a></h2>
<blockquote>
<p>or default type parameters, for example the <strong>fragment</strong> &lt;T: std::ops::Add&lt;Output = T&gt;&gt; says that T must implement trait std::ops::Add. Using a single type variable T with the trait bound ensures that arguments i and j, as well as the result type, are the same type and that their type supports addition.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {  type Output; fn add(self, rhs: Rhs) -&gt; Self::Output;}
<span class="boring">}
</span></code></pre></pre>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<p>The following table shows the relation between arithmetic operators and traits:</p>
<p>Operator	Trait
a + b 	Add
a - b 	Sub
-a 	Neg
a * b 	Mul
a / b 	Div
a % b 	Rem</p>
<blockquote>
<p>Apart from Rem, which is an abbreviation for Remainder, also known as mod in some other languages, those are pretty obvious. The binary operator traits all have a RHS (=right-hand-side) generic type bound which defaults to Self, as well as an associated Output type that the implementation has to declare.</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[rhs]] [[DEFAULT_CONCRETE_TYPE]] [[arithmetic]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>There are two types of variables in terms of scope: local, global</p>
</blockquote>
<h2 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h2>
<blockquote>
<p>A variable that takes the same name in the inner block as that of variable in the outer block. This concept is called shadowing.
Unlike let variables, const variables cannot be shadowed.
Variable shadowing is a technique in which a variable declared within a certain scope has the same name as a variable declared in an outer scope. This is also known as masking. This outer variable is said to be shadowed by the inner variable, while the inner variable is said to mask the outer variable.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[NUMERIC]]</p>
<p>[[NON_NUMERIC]]</p>
<p>–</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[PRIMITIVE]]</p>
<p>[[NUM]]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[types-size]]</p>
<p>[[types-float]]</p>
<p>[[types-radix]]</p>
<hr />
<blockquote>
<p>Rust’s standard library is comparatively slim. It excludes numeric types that are often available within other languages</p>
<p>Integers that assume the CPU’s “native” width. For example, in 64-bit CPUs, usize and isize will be 64-bits wide.</p>
</blockquote>
<p><img src="types/mscal/numeric/primitive/assets/table_2-2.png" alt="Sample Bits" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>[[o-bigint]]</p>
<p>[[o-bigrational]]</p>
<p>[[ria-float]]</p>
<p>[[ria-types-complex]]</p>
<hr />
<blockquote>
<p>A collection of numeric types and traits for Rust.
This includes new types for big integers, rationals, and complex numbers, new traits for generic programming on numeric properties like Integer, and generic range iterators.</p>
</blockquote>
<blockquote>
<p>We have some library for generic numbers that say <code>rug</code> has a better performance than <code>num</code>:</p>
</blockquote>
<p>Rug provides integers and floating-point numbers with arbitrary precision and correct rounding:</p>
<ul>
<li>Integer is a bignum integer with arbitrary precision,</li>
<li>Rational is a bignum rational number with arbitrary precision,</li>
<li>Float is a multi-precision floating-point number with correct rounding, and</li>
<li>Complex is a multi-precision complex number with correct rounding.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>[[STRING]]</p>
<p>[[CHAR]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[rd-types-string]]</p>
<p>[[re-types-string]]</p>
<p>[[pp-types-string]]</p>
<p>[[ria-types-string]]</p>
<p>[[mr-types-string]]</p>
<p>[[clap-types-string]]</p>
<p>[[other-types-string]]</p>
<hr />
<h2 id="str"><a class="header" href="#str">str</a></h2>
<p>str is a high-performance, relatively feature-poor type. Once created, <strong>str values cannot expand or shrink</strong>. In this sense, these are similar to interacting with <strong>a raw memory array</strong>. Unlike a raw memory array, though, str values are guaranteed to be valid UTF-8 characters.</p>
<p>str is usually seen in this form: &amp;str. A <strong>&amp;str (pronounced string slice)</strong> is a small type that contains a reference to str data and a length. Attempting to assign a variable to type str will fail. The Rust compiler wants to create fixed-sized variables within a function’s stack frame. As str values can be of arbitrary length, these can only be stored as local variables by reference.</p>
<h2 id="string-vs-str"><a class="header" href="#string-vs-str">String Vs str</a></h2>
<p>Passing &amp;str around your program is nearly free: it incurs nearly no allocation costs and no copying of memory.
owned strings (String) and borrowed strings (&amp;str).
A &amp;str is a borrowed type. In practical terms, this means that <strong>&amp;str can be thought of as read-only data</strong>, whereas <strong>String is read-write.String is an owned type.</strong>
“A String” is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity.
<strong>String store data on heap and refs to stack</strong></p>
<blockquote>
<p>One (&amp;str) is allocated on the stack, the other (String) allocates memory on the heap. That means that types cannot be trivially cast between one another. It’s possible, however, to work around this with Rust’s generics.</p>
</blockquote>
<blockquote>
<p><code>tags</code> [[as_ref]]  [[as_mut]] [[into]] [[GENERIC]]</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_strong&lt;T: AsRef&lt;str&gt;&gt;(password: T) -&gt; bool {
    password.as_ref().len() &gt; 5
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_strong&lt;T: Into&lt;String&gt;&gt;(password: T) -&gt; bool {
    password.into().len() &gt; 5
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="string-str-vs-char"><a class="header" href="#string-str-vs-char">String-str Vs char</a></h2>
<p>•char—A single character encoded as <strong>4 bytes</strong>. The internal representation of char is equivalent to UCS-4/UTF-32. This differs from &amp;str and String, which encodes single characters as UTF-8. Conversion does impose a penalty, but it means that char values are of fixed-width and are, therefore, easier for the [[COMPILER]]] to reason about. Characters encoded as UTF-8 can span 1 to 4 bytes.</p>
<p>•[u8]—<strong>A slice of raw bytes</strong>, usually found when dealing with streams of binary data.
It’s easy to get confused with slices [T], which do not have a compile-time length.
<strong>Slices are dynamically</strong> sized array-like objects.<u>The term dynamically sized means that their size is not known at compile time</u>. Yet, like arrays, these don’t expand or contract. 
The use of the word dynamic in dynamically sized is closer in meaning to dynamic typing rather than movement. 
The lack of compile-time knowledge explains the distinction in the type <u>signature between an array ([T; n ]) and a slice ([T]).</u></p>
<p>Slices are important because it’s easier to implement <em>traits for slices than arrays</em>. Traits are how Rust programmers add methods to objects. As [T; 1], [T; 2], …, [T; n ] are all different types, implementing traits for arrays can become unwieldy. </p>
<blockquote>
<p>Creating a slice from an array is easy and cheap because it doesn’t need to be tied to any specific size.</p>
</blockquote>
<p>Another important use for <u>slices is their ability to act as a view on arrays</u> (and other slices). The term view here is taken from database technology and means that <strong>slices can gain fast, read-only access to data without needing to copy anything around.</strong></p>
<p>The problem with slices is that Rust wants to know the size of every object in your program, and <strong>slices are defined as not having a compile-time size</strong>. References to the rescue. 
As mentioned in the discussion about the use of the term dynamically sized, slice size is fixed in memory. 
<strong>These are made up of two usize components (a pointer and a length).</strong>
hat’s why you typically see slices referred to in their referenced form, &amp;[T] (like string slices that take the notation &amp;str).</p>
<blockquote>
<p>In constrast to the String type, str is a built-in type known to the compiler and is not something from the standard library. String slices are created as &amp;str.The &amp;str types, once created, can’t be modified as they are created <strong>immutable</strong> by default.while String is a custom type from the standard library. You could implement your own similar String abstraction on top of Vec<u8>.</p>
</blockquote>
<blockquote>
<p>All <strong>stack</strong>-allocated values need to have a proper <strong>size known</strong> and, due to this, str cannot be initialized.</p>
</blockquote>
<pre><code class="language-rust compile_fail no_run ignore">let my_str: str = &quot;This is borrowed&quot;;
</code></pre>
<blockquote>
<p>Internally, &amp;String automatically coerces to &amp;str, due to the type <strong>#coercion trait Deref</strong> implemented for &amp;String to &amp;str. This is because String implements Deref for the str type.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">fn say_hello(to_whom: &amp;str) { 
    println!(&quot;Hey {}!&quot;, to_whom) 
} 

fn main() {     
    let string: String = string_slice.into();     
    say_hello(&amp;string); //No problem
}
</code></pre></pre>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<p>•Vec<u8> —<strong>A #vector of raw bytes</strong>, usually created when consuming [u8] data. </p>
<blockquote>
<p>String is to Vec<u8> as str is to [u8].
Vectors (Vec<T>) are growable lists of T
Using vectors is extremely common in Rust code. These incur a small runtime penalty compared to arrays because of the extra bookkeeping that must be done to enable their size to <em>change over time</em>. But vectors almost always make up for this with their added flexibility.
Vec<T> performs best when you can provide it with a size hint via Vec:: #with_capacity(). Providing an estimate minimizes the number of times memory will need to be allocated from the OS.
Lists of things are incredibly common. The two types that you will work with most often are arrays and vectors. 
Arrays are fixed-width and extremely lightweight.</p>
</blockquote>
<h2 id="oostring-vs-path"><a class="header" href="#oostring-vs-path">OOString Vs Path</a></h2>
<blockquote>
<p><code>out of bounds crashes</code></p>
</blockquote>
<p>• std::ffi:: [[OSString]] —A platform-native string. It’s behavior is close to String but without a guarantee that it’s encoded as #UTF-8 and that it won’t contain the zero byte (0x00).</p>
<p>• std:: [[path]] ::Path—A string-like type that is dedicated to handling filesystem paths.</p>
<h2 id="glossery-16"><a class="header" href="#glossery-16">Glossery</a></h2>
<blockquote>
<p><code>Literal</code> : “hello” called-&gt; string literal, equal=&gt; &amp;’static str.</p>
</blockquote>
<blockquote>
<p><code>Notation</code> : &amp;str(pronounced as stir), &amp;[]</p>
</blockquote>
<blockquote>
<p><code>{{{}}}</code> :  mustache-string interpolation - for printing {} in println!()</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[re-char]]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[ARRAY]]</p>
<p>[[TUPLE]]</p>
<p>[[UNION]]</p>
<p>[[ENUM]]</p>
<p>[[STRUCT]]</p>
<p>[[OPTION]]</p>
<hr />
<h1 id="glossery-17"><a class="header" href="#glossery-17">Glossery</a></h1>
<blockquote>
<p><code>Arity</code>: refers to the number of arguments a function or operator takes. For some examples, f(2, 3) and g(4, 6) have arity 2, while h(8, 2, 6) has arity 3. The ! operator has arity 1.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[edu-average]]</p>
<hr />
<blockquote>
<p>try to use nth instead of [index]</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];
assert_eq!(a.iter().nth(1), Some(&amp;2));
<span class="boring">}
</span></code></pre></pre>
<hr />
<blockquote>
<p><code>tags</code> [[len]] [[slice]] [[range]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><strong>Important Note:</strong> Use the dot operator (.) for accessing the values of the tuple. Do not use a debug trait.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>A union is similar to a struct, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. 
Accessing union fields is unsafe because <strong>Rust can’t guarantee</strong> the type of the data currently being stored in the <strong>union instance.</strong> 
At the time of writing this book, union types only allow Copy types as their fields. They share the same memory space with all of their fields, exactly like C unions.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[mr-destructure]]</p>
<p>[[re-struct]]</p>
<hr />
<blockquote>
<p>One of the ways this manifests is by not adding extra data around values within structs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Refutable patterns: Refutable pattern are let patterns <strong>where the left-hand side and the right-hand side are not compatible</strong> for pattern matching and, in those cases one has to use the exhaustive match expression instead. Up until now, all forms of let patterns we’ve seen were irrefutable patterns. Irrefutable means that they’re able to properly match against the value on the right side of ‘=’ as a valid pattern.</p>
</blockquote>
<blockquote>
<p><code>tags</code> [[pattern_matching]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>[[rd-thread-channel]]</p>
<p>[[rd-path]]</p>
<p>[[rd-file]]</p>
<p>[[rd-filesystem]]</p>
<p>[[rd-command-process]]</p>
<p>[[rd-command-process-pipe]]</p>
<p>[[rd-command-process-wait]]</p>
<p>[[rd-ffi]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread-channel"><a class="header" href="#thread-channel">thread-channel</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path"><a class="header" href="#path">path</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file"><a class="header" href="#file">file</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystem"><a class="header" href="#filesystem">filesystem</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-process"><a class="header" href="#command-process">command-process</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi"><a class="header" href="#ffi">ffi</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>[[RACE]]</p>
<p>[[RAYON]]</p>
<p>[[MPSC]]</p>
<p>[[ATOMIC]]</p>
<p>[[THREAD-TIME]]</p>
<p>[[UNSAFE-THREAD]]</p>
<p>[[THREAD-SHARESTATE]]</p>
<hr />
<blockquote>
<p>Rust provides a mechanism for spawning native OS threads via the spawn function, the argument of this function is a moving closure. These threads will be scheduled by the OS.</p>
</blockquote>
<blockquote>
<p>Rc<T> is not thread-safe. In multithreaded code, it’s much better to replace Rc<T> with Arc<T> and Rc&lt;RefCell<T>&gt; with Arc&lt;Mutex<T>&gt;. [[Arc]] stands for #atomic_reference_counter.</p>
</blockquote>
<h1 id="thread"><a class="header" href="#thread">Thread</a></h1>
<p><img src="thread/../rust/assets/images/thread1.JPG" alt="thread1" /></p>
<p><img src="thread/../rust/assets/images/thread2.JPG" alt="thread2" /></p>
<blockquote>
<p>Which parts of your code on different threads will run. This can lead to problems, such as:</p>
</blockquote>
<ul>
<li>Race conditions, where threads are accessing data or resources in an inconsistent order</li>
<li>Deadlocks, where two threads are waiting for each other to finish using a resource the other thread has, preventing both threads from continuing</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</li>
</ul>
<blockquote>
<p>Programming languages implement threads in a few different ways:
APIs to create threads is sometimes called 1:1, meaning one operating system thread per one language thread.the green-threaded model is called the M:N model: there are M green threads per N operating system threads, where M and N are not necessarily the same number.
The green-threading M:N model requires a larger language runtime to manage threads.
As such, the Rust standard library only provides an implementation of 1:1 threading.
Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade &gt; overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</p>
</blockquote>
<blockquote>
<p>Blocking a thread means that thread is prevented from performing work or exiting.</p>
</blockquote>
<blockquote>
<p>you can divide a calculation into independent parts, split those parts across threads, and then use a Mutex<T> to have each thread update the final result with its part.</p>
</blockquote>
<h2 id="threadstrategies"><a class="header" href="#threadstrategies">Thread•Strategies</a></h2>
<p><strong>Priority Performance:</strong>
<strong>Stealing Join:</strong></p>
<p>Calling join() is similar to spawning two threads.
Execute code in parallel when there are idle CPUs to handle it.</p>
<p><img src="thread/../rust/assets/images/thread-pool.png" alt="Stealing Join mechanism" /></p>
<p>In the complex world of concurrent programming, the concept of “Stealing Join” emerges as a <strong>distinctive strategy</strong>, adding a touch of finesse to the <strong>orchestration of threads</strong>. The notion revolves around the efficient coordination of threads in a way that complements Rust’s ownership system. threads are processing elements from the data vector concurrently, the “Stealing Join” strategy ensures a synchronized and efficient attribution to their individual tasks. This approach aligns with Rust’s philosophy of ownership transfer, <strong>allowing threads to gracefully finish their operations before joining the main thread.</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
fn main() {
let data = vec![1, 2, 3, 4, 5]; // ①
let mut handles = vec![]; // ②
for &amp;item in &amp;data { // ③
handles.push(thread::spawn(move || { // ④
println!(&quot;Processed: {}&quot;, item * 2); // ⑤
}));
}
for handle in handles { // ⑥
handle.join().unwrap(); // ⑦
}
}
// $ rustc thread.rs &amp;&amp; ./thread
// Output:
// Processed: 2
// Processed: 6
// Processed: 4
// Processed: 8
// Processed: 10
</code></pre></pre>
<p>In this illustrative example:
① We initialize a vector named data containing integers from 1 to 5.
② We create a mutable vector named handles to store thread handles.
③ Through iteration, we traverse the elements of the data vector using a reference.
④ We spawn a new thread using the thread::spawn function, ensuring that each thread takes ownership of the captured variable item.
⑤ Inside the thread, we print the processed result of doubling the item.
⑥ We iterate through the thread handles.
⑦ We employ the join method <strong>to ensure synchronization by waiting for each thread to complete</strong>.
In this code snippet, the concept of “move” takes center stage as threads are spawned to concurrently process elements from the data vector. The crucial use of the <strong>move keyword within the thread::spawn closure signifies the transfer of ownership for each iteration’s item</strong>. This elegant mechanism <strong>ensures that each thread exclusively possesses and operates on its own copy of the data</strong>, <em>mitigating the risk of data races and conflicts.</em> In other words, <strong>“move” in Rust orchestrates</strong> a ballet of ownership transfer, enabling a seamless and <em>safe parallel execution</em> where each thread <em>holds a distinct piece of the environment</em>, contributing to the overall performance without compromising data integrity.</p>
<p>When join is called from outside the thread pool, <strong>the calling thread will block while the closures execute in the pool.</strong> </p>
<blockquote>
<p>When join is called within the pool, the calling thread still actively participates in the thread pool. It will begin by executing closure A (on the current thread). While it is doing that, it will advertise closure B as being available for other threads to execute. Once closure A has completed, the current thread will try to execute closure B; if however closure B has been stolen, then it will look for other work while waiting for the thief to fully execute closure B. (This is the typical work-stealing strategy).
Send is require because we have jump from quick func(thread a) to part func(thread b) frequently</p>
</blockquote>
<p><strong>Atomic:</strong></p>
<blockquote>
<p>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.
This module defines atomic versions of a select number of primitive types, including AtomicBool, AtomicIsize, AtomicUsize, AtomicI8, AtomicU16, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</p>
</blockquote>
<blockquote>
<p>Each method takes an Ordering which represents the strength of the memory barrier for that operation. These orderings are the same as the C++20 atomic orderings. For more information see the nomicon.
Atomic variables are safe to share between threads (they implement Sync) but they do not themselves provide the mechanism for sharing and follow the threading model of Rust. The most common way to share an atomic variable is to put </p>
</blockquote>
<blockquote>
<p>it into an Arc (an atomically-reference-counted shared pointer).
Atomic types may be stored in static variables, initialized using the constant initializers like AtomicBool::new Atomic statics are often used for lazy global initialization.</p>
</blockquote>
<p><strong>Spin_Loop_Yeild:</strong></p>
<blockquote>
<p>also known as busy loop and spin loop-If you want to sleep pause a thread for short amounts of time, or if your application is sensitive to timing, use a spin loop</p>
</blockquote>
<p><strong>Sleep:</strong></p>
<blockquote>
<p>A sleep is a request to the OS that the thread should be suspended until the time has passed</p>
</blockquote>
<h2 id="threadspawning"><a class="header" href="#threadspawning">Thread•Spawning</a></h2>
<blockquote>
<p>Threads are the primary mechanism that operating systems provide for enabling concurrent execution. Modern operating systems ensure that each thread has fair access to the CPU. Understanding how to create threads (often referred to as spawning treads) and understanding their impact are fundamental skills for programmers wanting to make use of multi-core CPUs.</p>
</blockquote>
<blockquote>
<p>threads “don’t scale.” What does that mean?
Every thread requires its own memory, and by implication, we’ll eventually exhaust our system’s memory. Before that terminal point, though, thread creation begins to trigger slowdowns in other areas. As the number of threads to schedule increases, the OS scheduler’s work increases. When there are many threads to schedule, deciding which thread to schedule next takes more time.
Spawning threads is not free. It demands memory and CPU time. Switching between threads also invalidates caches.</p>
</blockquote>
<blockquote>
<p>if you’re thinking that sleeping is not a representative workload, It asks each thread to enter a spin loop. spin loop sterategy is better(performance) than sleep strategy.</p>
</blockquote>
<blockquote>
<p>It’s also possible to use both: sleep for the bulk of the time and a spin loop towards the end.
Second, CPU-intensive multithreading doesn’t scale well past the number of physical cores.</p>
</blockquote>
<h3 id="threadspawinmovecapture"><a class="header" href="#threadspawinmovecapture">Thread•Spawin•Move•Capture</a></h3>
<blockquote>
<p>The move closure is often used alongside thread::spawn because it allows you to use data from one thread in another thread.</p>
</blockquote>
<blockquote>
<p>we’re not using any data from the main thread in the spawned thread’s code. To use data from the main thread in the spawned thread, the spawned thread’s closure must capture the values it needs.</p>
</blockquote>
<blockquote>
<p>The move keyword overrides Rust’s conservative default of borrowing; it doesn’t let us violate the ownership rules.</p>
</blockquote>
<blockquote>
<p>move closures may still implement Fn or FnMut, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them</p>
</blockquote>
<blockquote>
<p>When the spawned thread wants to access variables that are defined in the parent’s scope, called a capture, Rust often complains that captures must be moved into the closure. To indicate that you want to move ownership, anonymous functions take a move keyword:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{thread, time};
thread::spawn(move || {
    // ...
});
<span class="boring">}
</span></code></pre></pre>
<h3 id="threadspawningjoin"><a class="header" href="#threadspawningjoin">Thread•Spawning•Join</a></h3>
<blockquote>
<p>join is an extension of the thread metaphor. When threads are spawned, these are said to have forked from their parent thread. To join threads means to weave these back together again.</p>
</blockquote>
<blockquote>
<p>In practice, join means wait for the other thread to finish. The join() function instructs the OS to defer scheduling the calling thread until the other thread finishes.</p>
</blockquote>
<blockquote>
<p>.join()//means guarantee - waiting for All Threads to Finish Using join Handles. A JoinHandle is an owned value that, when we call the join method on it, will wait for its thread to finish.</p>
</blockquote>
<h3 id="threadjoinworkstealing"><a class="header" href="#threadjoinworkstealing">Thread•Join•WorkStealing</a></h3>
<blockquote>
<p>Takes two closures and potentially runs them in parallel. It returns a pair of the results from those closures.</p>
</blockquote>
<blockquote>
<p>Conceptually, calling join() is similar to spawning two threads, one executing each of the two closures. However, the implementation is quite different and incurs very low overhead. The underlying technique is called “work stealing”: the Rayon runtime uses a fixed pool of worker threads and attempts to only execute code in parallel when there are idle CPUs to handle it.</p>
</blockquote>
<blockquote>
<p>When join is called from outside the thread pool, the calling thread will block while the closures execute in the pool. When join is called within the pool, the calling thread still actively participates in the thread pool. It will begin by executing closure A (on the current thread). While it is doing that, it will advertise closure B as being available for other threads to execute. Once closure A has completed, the current thread will try to execute closure B; if 
however closure B has been stolen, then it will look for other work while waiting for the thief to fully execute closure B. (This is the typical work-stealing strategy).</p>
</blockquote>
<h3 id="threadrectry"><a class="header" href="#threadrectry">Thread•Rec•Try</a></h3>
<blockquote>
<p>We’re using recv, short for receive, which will block the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, recv will return it in a Result&lt;T, E&gt;. When the sending end of the channel closes, recv will return an error to signal that no more values will be coming.</p>
</blockquote>
<blockquote>
<p>The try_recv method doesn’t block, but will instead return a Result&lt;T, E&gt; immediately: an Ok value holding a message if one is available and an Err value if there aren’t any messages this time. Using try_recv is useful if this thread has other work to do while waiting for messages: we could write a loop that calls try_recv every so often, handles a message if one is available, and otherwise does other work for a little while until checking again</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[pnkfx-mpsc]]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[rd-rayon]]</p>
<p>[[pp-rayon]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync_atomic_mutex"><a class="header" href="#sync_atomic_mutex">Sync_Atomic_Mutex</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>[[pnkfx-mpsc]]</p>
<p>[[ria-mpsc]]</p>
<hr />
<blockquote>
<p>Using Message Passing to <strong>Transfer Data Between Threads</strong>:
Here’s the idea in a slogan from the Go language documentation: </p>
<p><strong>“Do not communicate by sharing memory; instead, share memory by communicating.”</strong></p>
</blockquote>
<blockquote>
<p>One major tool Rust has for accomplishing message-sending concurrency is the channel,
A channel in programming has two halves: a transmitter and a receiver. 
A channel is said to be closed if either the transmitter or receiver half is dropped.</p>
</blockquote>
<blockquote>
<p>We create a new channel using the mpsc::channel function; mpsc stands for multiple producer, single consumer. In short, the way Rust’s standard library implements channels <strong>means a channel can have multiple sending ends that produce values but only one receiving end that consumes those values.</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-thread-time]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[pp-command]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p><img src="tests/../rust/assets/images/effective-property-based-testing-1.png" alt="safetay-control" /></p>
<hr />
<ul>
<li>Unit tests are often put in a nested module.</li>
<li>This lets you unit test private helpers.</li>
<li>The #[cfg(test)] attribute is only active when you run cargo test.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn helper(a: &amp;str, b: &amp;str) -&gt; String {
    format!(&quot;{a} {b}&quot;)
}

pub fn main() {
    println!(&quot;{}&quot;, helper(&quot;Hello&quot;, &quot;World&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper() {
        assert_eq!(helper(&quot;foo&quot;, &quot;bar&quot;), &quot;foo bar&quot;);
    }
}
</code></pre></pre>
<h2 id="documentation-test"><a class="header" href="#documentation-test">Documentation Test</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A function that panics. expect param not support yet.
////
/// ```should_panic
/// use mypackagename::whoops;
/// whoops();
/// ```
pub fn whoops() {
    panic!(&quot;😱&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="differences-between-quickcheck-and-proptest"><a class="header" href="#differences-between-quickcheck-and-proptest">Differences between QuickCheck and Proptest</a></h2>
<blockquote>
<p>QuickCheck and Proptest are similar in many ways: 
both generate <strong>random inputs</strong> for a function to <strong>check certain properties</strong>, and automatically <strong>shrink inputs</strong> to minimal failing cases.</p>
</blockquote>
<p>The one big difference is that <strong>QuickCheck generates and shrinks values based on type alone</strong>, whereas Proptest uses explicit Strategy objects. The QuickCheck approach has a lot of disadvantages in comparison:</p>
<p>QuickCheck can only define one generator and shrinker per type. If you need <strong>a custom generation strategy</strong>, <em>you need to wrap it in a newtype and implement traits on that by hand. In Proptest,</em> you can define arbitrarily many different strategies for the same type, and there are plenty built-in.</p>
<p><em>For the same reason, QuickCheck has a single “size” configuration that tries to define the range of values generated. If you need an integer between 0 and 100 and another between 0 and 1000, you probably need to do another newtype. In Proptest, you can directly just express that you want a 0..100 integer and a 0..1000 integer.</em></p>
<p>Types in QuickCheck are not easily composable. Defining Arbitrary and Shrink for a new struct which is simply produced by the composition of its fields requires implementing both by hand, including a bidirectional mapping between the struct and a tuple of its fields. In Proptest, you can make a tuple of the desired components and then prop_map it into the desired form. Shrinking happens automatically in terms of the input types.</p>
<p>Because constraints on values cannot be expressed in QuickCheck, generation and shrinking may lead to a lot of input rejections. 
<strong>Strategies in Proptest are aware of simple constraints and do not generate or shrink to values that violate them.</strong></p>
<table><thead><tr><th align="center">Features</th><th align="center">QuickCheck</th><th align="center">Proptest</th></tr></thead><tbody>
<tr><td align="center">Random Input</td><td align="center">*</td><td align="center">*</td></tr>
<tr><td align="center">Shrink inputs</td><td align="center">*</td><td align="center">-</td></tr>
<tr><td align="center">Performance/Speed</td><td align="center">Great</td><td align="center">Good</td></tr>
<tr><td align="center">Perform</td><td align="center">Stateless</td><td align="center">Full-state</td></tr>
<tr><td align="center">Shrink values</td><td align="center">*</td><td align="center">-</td></tr>
<tr><td align="center">Generation/Shrink strategy</td><td align="center">per-type/specific type</td><td align="center">per-value/Custom generator(constraint)</td></tr>
</tbody></table>
<h2 id="unit-vs-integration-test"><a class="header" href="#unit-vs-integration-test">Unit vs Integration Test</a></h2>
<p>As the name suggests, these test the public API of a service/crate. These tests are used to test the functionalities of a program. <strong>Integration tests are placed in separate files, unlike the unit tests, which are present in the same file.</strong> Additionally, integration tests are useful for ensuring the public APIs don’t change and the expected usage of the program is not broken. <em>These tests reside in tests folder in the root of the crate</em></p>
<h2 id="black-vs-white-boxes"><a class="header" href="#black-vs-white-boxes">Black vs white boxes</a></h2>
<p>In this case, the parse method belongs to the public interface, so the test is a <em>black-box</em> test, meaning it only uses the <strong>public API</strong> of your crate. <strong>Black-box tests usually belong in one or more files in the tests subdirectory</strong> of your crate. A good convention is to have one test file per module to make it easy to find the corresponding tests.</p>
<p>Sometimes, it makes sense to test <strong>private functionality to better pinpoint a bug or regression</strong>. Those tests are called <em>white-box</em> tests. Because they need to access the crate internals, they must be defined within the crate. The best practice is to <strong>include a test submodule</strong> directly in your crate and only compile it under test, like so:</p>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::{parse_inner, check};

    #[test]
    fn test_parse_inner() { .. }

    #[test]
    fn test_check() { .. }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[test-unit]]</p>
<p>[[test_proptest]]</p>
<p>[[test-proptest_runner]]</p>
<p>[[test-pretty]]</p>
<p>[[test-fixture]]</p>
<p>[[test-integration]]</p>
<p>[[test-independent]]</p>
<p>[[test-dependent]]</p>
<hr />
<ul>
<li><a href="tests/test_structures/test_unit/test-unit.html">Unit</a></li>
<li><a href="tests/test_structures/test_dependent/test-dependent.html">Dependent</a></li>
<li><a href="tests/test_structures/test_independent/test-independent.html">Independent</a></li>
<li><a href="tests/test_structures/test_integration/test-integration.html">Integration</a></li>
<li><a href="tests/test_structures/test_fixture/test-fixture.html">fixture</a></li>
<li><a href="tests/test_structures/test_pretty/test-pretty.html">Pretty</a></li>
<li><a href="tests/test_structures/test_proptest/test-proptest.html">Proptest</a></li>
<li><a href="tests/test_structures/test_proptest_runner/test-proptest_runner.html">ProptestRunner</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[unit_test]] </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[test_unit]] [[pretty_assertions]] [[test]]</p>
</blockquote>
<h2 id="tip"><a class="header" href="#tip">Tip</a></h2>
<p>Specify it as [dev-dependencies] and it will only be used for compiling tests, examples, and benchmarks. This way the compile time of cargo build won’t be affected!</p>
<p>Also add #[cfg(test)] to your use statements, like this:</p>
<p>#[cfg(test)]
use pretty_assertions::{assert_eq, assert_ne};</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[test_proptest]] [[test]] #proptest</p>
</blockquote>
<h2 id="proptest"><a class="header" href="#proptest">Proptest</a></h2>
<p>Proptest is a property testing framework (i.e., the QuickCheck family) inspired by the Hypothesis framework for Python. It allows to test that certain properties of your code hold for arbitrary inputs, and <strong>if a failure is found,</strong>  <em>automatically finds the minimal test case to reproduce the problem</em>. <strong>Unlike QuickCheck, generation and shrinking is defined on a per-value basis instead of per-type</strong>, which makes it more flexible and simplifies composition.</p>
<h2 id="what-is-property-testing"><a class="header" href="#what-is-property-testing">What is property testing?</a></h2>
<p>Property testing is a system of testing code by checking that certain properties of its output or behaviour are fulfilled for all inputs.
Property testing is best used to complement traditional unit testing (i.e., using specific inputs chosen by hand). <em>Traditional tests can test specific known edge cases, simple inputs, and inputs that were known in the past to reveal bugs,</em> <strong>whereas property tests will search for more complicated inputs that cause problems.</strong></p>
<h2 id="property-pattern"><a class="header" href="#property-pattern">Property Pattern</a></h2>
<p>Now we can add some property tests to our date parser. But <em>how do we test the date parser for arbitrary inputs, without making another date parser in the test to validate it?</em> We won’t need to as long as we choose our inputs and properties correctly. </p>
<blockquote>
<p>But <strong>before correctness</strong>, there’s actually an even simpler property to test: <strong>The function should not crash.</strong> Let’s start there.</p>
</blockquote>
<pre><code>// Bring the macros and other important things into scope.
use proptest::prelude::*;

proptest! {
    #[test]
    fn doesnt_crash(s in &quot;\\PC*&quot;) {
        parse_date(&amp;s);
    }
}
</code></pre>
<p>What this does is take a literally random &amp;String (ignore \PC* for the moment, we’ll get back to that — if you’ve already figured it out, contain your excitement for a bit) and give it to parse_date() and then throw the output away.</p>
<p>When we run this, we get a bunch of scary-looking output, eventually ending with</p>
<pre><code>thread 'main' panicked at 'Test failed: byte index 4 is not a char boundary; it is inside 'ௗ' (bytes 2..5) of `aAௗ0㌀0`; minimal failing input: s = &quot;aAௗ0㌀0&quot;
	successes: 102
	local rejects: 0
	global rejects: 0
'
</code></pre>
<p>If we look at the top directory after the test fails, we’ll see a new proptest-regressions directory, which contains some files corresponding to source files containing failing test cases. These are failure persistence files. The first thing we should do is add these to source control.</p>
<pre><code>$ git add proptest-regressions
</code></pre>
<p>The next thing we should do is copy the failing case to a traditional unit test since it has exposed a bug not similar to what we’ve tested in the past.</p>
<pre><code>#[test]
fn test_unicode_gibberish() {
    assert_eq!(None, parse_date(&quot;aAௗ0㌀0&quot;));
}
</code></pre>
<p>Now, let’s see what happened… we forgot about UTF-8! You can’t just blindly slice strings since you could split a character, in this case that Tamil diacritic placed atop other characters in the string.</p>
<p>In the interest of making the code changes as small as possible, we’ll just check that the string is ASCII and reject anything that isn’t.</p>
<pre><code>fn parse_date(s: &amp;str) -&gt; Option&lt;(u32, u32, u32)&gt; {
    if 10 != s.len() { return None; }

    // NEW: Ignore non-ASCII strings so we don't need to deal with Unicode.
    if !s.is_ascii() { return None; }

    if &quot;-&quot; != &amp;s[4..5] || &quot;-&quot; != &amp;s[7..8] { return None; }

    let year = &amp;s[0..4];
    let month = &amp;s[6..7];
    let day = &amp;s[8..10];

    year.parse::&lt;u32&gt;().ok().and_then(
        |y| month.parse::&lt;u32&gt;().ok().and_then(
            |m| day.parse::&lt;u32&gt;().ok().map(
                |d| (y, m, d))))
}
</code></pre>
<p>The tests pass now! But we know there are still more problems, so let’s test more properties.</p>
<p>Another property we want from our code is that it parses every valid date. We can add another test to the proptest! section:</p>
<pre><code>proptest! {
    // snip...

    #[test]
    fn parses_all_valid_dates(s in &quot;[0-9]{4}-[0-9]{2}-[0-9]{2}&quot;) {
        parse_date(&amp;s).unwrap();
    }
}
</code></pre>
<p>The thing to the right-hand side of in is actually a regular expression, and s is chosen from strings which match it. So in our previous test, “\PC*” was generating arbitrary strings composed of arbitrary non-control characters. Now, we generate things in the YYYY-MM-DD format.</p>
<p>The new test passes, so let’s move on to something else.</p>
<p>The final property we want to check is that the dates are actually parsed correctly. Now, we can’t do this by generating strings — we’d end up just reimplementing the date parser in the test! Instead, we start from the expected output, generate the string, and check that it gets parsed back.</p>
<pre><code>proptest! {
    // snip...

    #[test]
    fn parses_date_back_to_original(y in 0u32..10000,
                                    m in 1u32..13, d in 1u32..32) {
        let (y2, m2, d2) = parse_date(
            &amp;format!(&quot;{:04}-{:02}-{:02}&quot;, y, m, d)).unwrap();
        // prop_assert_eq! is basically the same as assert_eq!, but doesn't
        // cause a bunch of panic messages to be printed on intermediate
        // test failures. Which one to use is largely a matter of taste.
        prop_assert_eq!((y, m, d), (y2, m2, d2));
    }
}
</code></pre>
<p>Here, we see that besides regexes, we can use any expression which is a proptest::strategy::Strategy, in this case, integer ranges.</p>
<p>The test fails when we run it. Though there’s not much output this time.</p>
<pre><code>thread 'main' panicked at 'Test failed: assertion failed: `(left == right)` (left: `(0, 10, 1)`, right: `(0, 0, 1)`) at examples/dateparser_v2.rs:46; minimal failing input: y = 0, m = 10, d = 1
	successes: 2
	local rejects: 0
	global rejects: 0
', examples/dateparser_v2.rs:33
note: Run with `RUST_BACKTRACE=1` for a backtrace.

The failing input is (y, m, d) = (0, 10, 1), which is a rather specific output. Before thinking about why this breaks the code, let's look at what proptest did to arrive at this value. At the start of our test function, insert

println!(&quot;y = {}, m = {}, d = {}&quot;, y, m, d);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[test_proptest_runner]] [[test]] #runner #proptest</p>
</blockquote>
<h2 id="test-compound-strategies"><a class="header" href="#test-compound-strategies">Test Compound Strategies</a></h2>
<p>Testing functions that take single arguments of primitive types is nice and all, but is kind of underwhelming. Back when we were writing the whole stack by hand, extending the technique to, say, two integers was clear, if verbose. But TestRunner only takes a single Strategy; </p>
<blockquote>
<p>How can we test a function that needs inputs from more than one?</p>
</blockquote>
<h2 id="how"><a class="header" href="#how">How</a></h2>
<p>Other compound strategies include fixed-sizes arrays of strategies and Vecs of strategies (which produce arrays or Vecs of values parallel to the strategy collection), as well as the <strong>various strategies</strong> provided in the <strong>collection module</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>tags</code> [[test_fixture]] [[test]]</p>
</blockquote>
<h2 id="fixture"><a class="header" href="#fixture">Fixture</a></h2>
<p>A fixture is something that you can use in your tests to encapsulate a test’s dependencies.</p>
<p>The general idea is to have smaller tests that only describe the thing you’re testing while you hide the auxiliary utilities your tests make use of somewhere else. For instance, if you have an application that has many <em>tests with users, shopping baskets, and products, you’d have to create a user, a shopping basket, and product every single time in every test which becomes unwieldy quickly.</em> In order to cut down on that repetition, you can instead use fixtures to declare that you need those objects for your function and the fixtures will take care of creating those by themselves. Focus on the important stuff in your tests!</p>
<p>In rstest a fixture is a function that can return any kind of valid Rust type. This effectively means that your fixtures are not limited by the kind of data they can return. <strong>A test can consume an arbitrary number of fixtures at the same time.</strong></p>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[fixture]
fn alice_and_bob(mut empty_repository: impl Repository) -&gt; impl Repository {
    empty_repository.add(&quot;Bob&quot;, 21);
    empty_repository.add(&quot;Alice&quot;, 22);
    empty_repository
}

#[rstest]
fn should_process_two_users(alice_and_bob: impl Repository,
                            string_processor: FakeProcessor) {
    string_processor.send_all(&quot;Good Morning&quot;);

    assert_eq!(2, string_processor.output.find(&quot;Good Morning&quot;).count());
    assert!(string_processor.output.contains(&quot;Bob&quot;));
    assert!(string_processor.output.contains(&quot;Alice&quot;));
}
<span class="boring">}
</span></code></pre></pre>
<p>Injecting fixtures as function arguments</p>
<p>rstest functions can receive fixtures by using them as input arguments. A function decorated with [rstest] will resolve each argument name by call the fixture function. Fixtures should be annotated with the [fixture] attribute.</p>
<p>Fixtures will be resolved like function calls by following the standard resolution rules. Therefore, an identically named fixture can be use in different context.</p>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod empty_cases {
    use super::*;

    #[fixture]
    fn repository() -&gt; impl Repository {
        DataSet::default()
    }

    #[rstest]
    fn should_do_nothing(repository: impl Repository) {
        //.. test impl ..
    }
}

mod non_trivial_case {
    use super::*;

    #[fixture]
    fn repository() -&gt; impl Repository {
        let mut ds = DataSet::default();
        // Fill your dataset with interesting case
        ds
    }

    #[rstest]
    fn should_notify_all_entries(repository: impl Repository) {
        //.. test impl ..
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod fixt {

    #[rstest]
    #[case(&quot;1.2.3.4:8080&quot;, 8080)]
    #[case(&quot;127.0.0.1:9000&quot;, 9000)]
    fn check_port(#[case] addr: SocketAddr, #[case] expected: u16) {
        assert_eq!(expected, addr.port());
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[test-binary]]</p>
<hr />
<p><a href="tests/tests_samples/test_binary/test-binary.html">test-binary</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>[[EXTERN-FFI]]</p>
<p>[[SAFE_ABSTRACTION]]</p>
<p>[[SAFE_STATIC_MUT]]</p>
<p>[[THREAD_UNSAFE]]</p>
<hr />
<blockquote>
<p>An unsafe block implies that the programmer takes full responsibility for any consequences</p>
</blockquote>
<blockquote>
<p>When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs than to accept some invalid programs. Although the code might be okay, <em>if the Rust compiler doesn’t have enough information to be confident, it will reject the code</em>. In these cases, you can use <strong>unsafe code to tell the compiler, “Trust me, I know what I’m doing.”</strong> Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing.
It’s important to understand that unsafe doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. The unsafe keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe block.</p>
</blockquote>
<blockquote>
<p>In addition, unsafe does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an unsafe block will access memory in a valid way.</p>
</blockquote>
<blockquote>
<p>Keep unsafe blocks small; you’ll be thankful later when you investigate memory bugs.</p>
</blockquote>
<blockquote>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API,  Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. <strong>Wrapping unsafe</strong> code in a safe abstraction prevents uses of unsafe from leaking out into all the places that you or your users might want to use the functionality implemented with unsafe code, because using a safe abstraction is safe.</p>
</blockquote>
<h2 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h2>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
<li>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut num = 5;
    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p>Notice that we don’t include the unsafe keyword in this code. We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a bit.</p>
<p>We’ve created raw pointers by using as to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can’t make that assumption about just any raw pointer.</p>
<p>To demonstrate this, next we’ll create a raw pointer whose validity we can’t be so certain of. Listing below shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a #segmentation_fault. Usually, there is no good reason to write code like this, but it is possible.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2); //datarace
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h2>
<blockquote>
<p>By calling an unsafe function within an unsafe block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h2>
<p>The final action that works only with unsafe is accessing fields of a union. A union is similar to a struct, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because <strong>Rust can’t guarantee the type of the data currently being stored in the union instance.</strong></p>
<p>This will be laid out equivalently to the following more complex Rust types:</p>
<pre><pre class="playground"><code class="language-rust  no_run  compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// C-compatible layout with a specified discriminant size:
// #[repr(C, u8)]
// A specific integer type (called Int as a shorthand below):
// #[repr(u8)]
// 4 bytes with #[repr(u8)], but would occupy 6 bytes with #[repr(C, u8)], as more padding is required

#[repr(C)]
union TwoCasesRepr {
    A: TwoCasesVariantA,
    B: TwoCasesVariantB,
}
        
#[repr(u8)]
enum TwoCasesTag { A, B }

#[repr(C)]
struct TwoCasesVariantA(TwoCasesTag, u8, u16);

#[repr(C)]
struct TwoCasesVariantB(TwoCasesTag, u16);
<span class="boring">}
</span></code></pre></pre>
<h2 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">When to Use Unsafe Code</a></h2>
<p>Using unsafe to take one of the five actions (superpowers) just discussed isn’t wrong or even frowned upon. But it is trickier to get unsafe code correct because the compiler can’t help uphold memory safety. When you have a reason to use unsafe code, you can do so, and having the explicit unsafe annotation makes it easier to track down the source of problems when they occur.</p>
<h2 id="more-info"><a class="header" href="#more-info">More Info</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines">Unsafe Code Guidelines</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>[[rd-ffi]]</p>
<hr />
<blockquote>
<p>Functions declared within extern blocks are always unsafe to call from Rust code.
The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.</p>
</blockquote>
<blockquote>
<p>the “C” part defines which application binary interface (ABI) the external function uses: the ABI defines how to call the function at the assembly level. </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}
fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<h2 id="no-mangle"><a class="header" href="#no-mangle">No Mangle</a></h2>
<p>The <code>#[no_mangle]</code> attribute in Rust is used to instruct the compiler not to mangle the name of the function or item it is applied to. Name mangling is a common technique used by compilers to generate unique names for functions, variables, and other identifiers when they are compiled into machine code. This process helps avoid naming conflicts between different parts of a program or between programs.</p>
<p>By default, Rust applies name mangling to all items (functions, structs, enums, etc.) to ensure that each has a unique identifier in the compiled output. However, there are cases where you might want to control this behavior, especially when interfacing with C libraries or when you need to expose certain Rust functions to be called directly from C code without mangling.</p>
<p>Here’s how you can use <code>#[no_mangle]</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn my_function() {
    // Function body here
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, <code>my_function</code> will not have its name mangled, making it possible to call this function directly from C code. The <code>extern &quot;C&quot;</code> part specifies that the function uses the C calling convention, which is necessary for interoperability with C code.</p>
<p>It’s important to note that using <code>#[no_mangle]</code> should be done judiciously, as it can lead to name clashes if not managed carefully. Additionally, since Rust’s name mangling scheme is designed to produce unique names, manually specifying names can potentially introduce conflicts within large projects or across different crates.</p>
<p>For more complex scenarios involving external libraries or specific requirements for ABI compatibility, consider using Rust’s Foreign Function Interface (FFI) features along with <code>#[no_mangle]</code>. These tools allow Rust to interoperate with code written in other languages, facilitating the integration of Rust into existing systems or applications.</p>
<h2 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using extern Functions to Call External Code</a></h2>
<blockquote>
<p>Rust has the keyword extern that facilitates the creation and use of a Foreign Function Interface (FFI). An #FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.
extern “C” block, we list the names and signatures of external functions from another language we want to call. The “C” part defines which application binary interface (ABI) the external function uses: the #ABI defines how to call the function at the assembly level. The “C” ABI is the most common and follows the C programming language’s ABI.</p>
</blockquote>
<blockquote>
<p>We also need to add a #[no_mangle] annotation to tell the Rust compiler not to mangle the name of this function. Mangling is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling.</p>
</blockquote>
<blockquote>
<p>In the following example, we make the call_from_c function accessible from C code, after it’s compiled to a shared library and linked from C:</p>
</blockquote>
<blockquote>
<p>We can also use extern to create an interface that <strong>allows other languages to call Rust functions</strong>. Instead of creating a whole extern block, we add the extern keyword and specify the ABI to use just before the fn keyword for the relevant function. We also need to <strong>add a #[no_mangle] annotation</strong> to tell the Rust compiler not to mangle the name of this function. Mangling is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, <strong>we must disable the Rust compiler’s name mangling.</strong></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused)]
fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
}
</code></pre></pre>
<ul>
<li>
<p><a href="https://cratecode.com/info/rust-ffi">Rust FFI</a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/unsafe/asm.html">ASM FFI</a></p>
</li>
</ul>
<blockquote>
<p><code>tags</code> #C #ffi #abi #asm</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[rd-safe-abstraction]]</p>
<hr />
<h2 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h2>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let’s study the split_at_mut function from the standard library, which requires some unsafe code. We’ll explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use split_at_mut.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
fn main(){

    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);

} 
fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..]) //error
}

</code></pre></pre>
<pre><code class="language-compile_fail no_run">error[E0499]: cannot borrow `*values` as mutable more than once at a time
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Shows how to use an unsafe block, a raw pointer, and some calls to unsafe functions to make the implementation of split_at_mut work.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}

<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that we don’t need to mark the resulting split_at_mut function as unsafe, and we can call this function from safe Rust. We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses unsafe code in a safe way, because it creates only valid pointers from the data this function has access to. Attempting to use values as though it’s a valid slice results in undefined behavior.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };

<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>tags</code> [[split_at_mut]] [[from_raw_parts_mut]] [[as_mut_ptr]] [[raw_pointer]] [[pointer]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[rd-safe-static-mut]]</p>
<hr />
<blockquote>
<p>Until now, we’ve not talked about global variables, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.
’static lifetime, which means the Rust compiler can figure out the lifetime and we aren’t required to annotate it explicitly. Accessing an immutable static variable is safe.</p>
</blockquote>
<h2 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h2>
<p>In this book, we’ve not yet talked about global variables, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are <strong>accessing the same mutable global variable, it can cause a data race.</strong> #data_race
In Rust, global variables are called static variables.</p>
<pre><pre class="playground"><code class="language-rust edition2021">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<blockquote>
<p>Accessing and modifying mutable static variables is unsafe.static variable have a fixed address in memory.</p>
</blockquote>
<blockquote>
<p>With mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<blockquote>
<p><code>tags</code> </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h2>
<p>Another use case for unsafe is implementing an unsafe trait. </p>
<p>A trait is unsafe when at least one of its methods has some invariant that By using unsafe impl, we’re promising that  we’ll uphold the invariants that the compiler can’t verify.</p>
<p>We can declare that a trait is unsafe by adding the unsafe keyword before trait and marking the implementation of the </p>
<p>By using unsafe impl, we’re promising that we’ll uphold the invariants that the compiler can’t verify.</p>
<p><code>As an example,</code> recall the Sync and Send marker traits, the compiler implements these traits automatically if our types are composed entirely of Send and Sync types. </p>
<p>If we implement a type that contains a type that is not Send or Sync, such as raw pointers, and <strong>we want to mark that type as Send or Sync, we must use unsafe</strong>. Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or <strong>accessed from multiple threads</strong>; therefore, we need to do those checks manually and indicate as such with unsafe.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait as unsafe too
{
Sync and Send are examples of unsafe traits.
}
unsafe trait Foo {
    // methods go here
}
unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">unsafe trait Foo {
    fn bar(&amp;self, other: i32) -&gt; i32;
}

unsafe impl Foo for i32 {
    fn bar(&amp;self, other: i32) -&gt; i32 {
        self * self + other * other
    }
}
fn main() {
    let x = 5;
    let y = 10;
    unsafe {
        println!(&quot;The result is {}&quot;, x.bar(y));
    }
}
</code></pre></pre>
<blockquote>
<p>Output: The result is 125</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[edu-macro]]</p>
<p>[[rd-macro]]</p>
<hr />
<p>Macros are the Rust metaprogramming feature that creates code in <strong>compile-time</strong>. Through this, we can <strong>save duplication</strong>, but we need to be careful because we could make a mess.</p>
<blockquote>
<p>The type of parameter or the fragment specifier is expr, but Rust offers other parameters as well:</p>
</blockquote>
<ul>
<li>[*] item: An item.</li>
<li>[*] block: A block expression.</li>
<li>[*] stmt: A statement.</li>
<li>[*] pat: A pattern.</li>
<li>[*] expr: An expression.</li>
<li>[*] ty: A type.</li>
<li>[*] ident: An identifier or a keyword.</li>
<li>[*] path: A type path.</li>
<li>[*] tt: A token.</li>
<li>[*] meta: The contents of an attribute.</li>
<li>[*] lifetime: A lifetime token.</li>
<li>[*] vis: A possibly empty visibility qualifier.</li>
<li>[*] literal: A literal expression.</li>
</ul>
<hr />
<blockquote>
<p>The best-case scenario for a macro is to avoid duplication.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>macro_rules! create_model {
    ($name:ident) =&gt; {
        #[allow(unused_variables)]
        #[allow(dead_code)]
        #[derive(Debug)]
        struct $name {
            product_details: Vec&lt;ProductDetail&gt;,
            date: Date,
            subtotal: Option&lt;f64&gt;,
            total_tax: f64,
            total: Option&lt;f64&gt;
        }
    }
}
create_model!(Sale);
create_model!(Purchase);
create_model!(Budget);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>tags</code> </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="relative-vs-self"><a class="header" href="#relative-vs-self">Relative vs Self</a></h2>
<p>By default, Rust recommends absolute imports within root modules. <strong>Absolute</strong> imports are done starting with the <strong>crate keyword</strong>, whereas relative imports are done using the <strong>self keyword</strong>. When re-exporting sub-modules to their parent modules, we might benefit from <strong>relative</strong> imports, <em>as using absolute imports becomes long and redundant</em>.</p>
<p>The privacy of items in Rust starts at the module level. As a library author, to expose things to users from a module, we use the pub keyword. But there are items that we only want to expose to other modules within the crate, but not to the users. In such cases, we can use the <em>-<strong>pub(crate)</strong> modifier for the item, which allows the item to be exposed only within the crate.</em></p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<h2 id="testing-a-bugfix"><a class="header" href="#testing-a-bugfix">Testing a bugfix</a></h2>
<p>Let’s say you’re working with the uuid crate but while you’re working on it you discover a bug. You are, however, quite enterprising so you decide to also try to fix the bug! Originally your manifest will look like:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0&quot;
<span class="boring">}
</span></code></pre></pre>
<p>First thing we’ll do is to clone the uuid repository locally via:
Next we’ll edit the manifest of my-library to contain:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
$ git clone https://github.com/uuid-rs/uuid.git
<span class="boring">}
</span></code></pre></pre>
<p>You’re now building with the local version of uuid (note the path in parentheses in the build output). If you don’t see the local path version getting built then you may need to run </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo update -p uuid --precise $version 
<span class="boring">}
</span></code></pre></pre>
<p>where $version is the version of the locally checked out copy of uuid.</p>
<p>Once you’ve fixed the bug you originally found the next thing you’ll want to do is to likely submit that as a pull request to the uuid crate itself. Once you’ve done this then you can also update the [patch] section. The listing inside of [patch] is just like the [dependencies] section, so once your pull request is merged you could change your path dependency to:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
<span class="boring">}
</span></code></pre></pre>
<h2 id="override"><a class="header" href="#override">Override</a></h2>
<p>In case the dependency you want to override isn’t loaded from crates.io, you’ll have to change a bit how you use [patch]. For example, if the dependency is a git dependency, you can override it to a local path with:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[patch.&quot;https://github.com/your/repository&quot;]
my-library = { path = &quot;../my-library/path&quot; }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[[PISTON]]</p>
<p>[[types-int]]</p>
<p>[[mr-size]]</p>
<p>[[POINTERS]]</p>
<hr />
<h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p><img src="memory/../rust/assets/images/mem-master1.JPG" alt="Memory" /></p>
<ul>
<li>Text segment: This section contains the actual code to be executed in the compiled binary. The text segment is a read-only segment and any user code is forbidden to modify it. Doing so can result in a crash of the program.</li>
<li>Data segment: This is further divided into subsections, that is, the initialized data segment and uninitialized data segment, which is historically known as Block Started by Symbol (BSS), and holds all global and static valuesdeclared in the program. Uninitialized values are initialized to zero when they are loaded into memory.</li>
<li>Stack segment: This segment is used to hold any local variables and the return addresses of functions. All resources whose sizes are known in advance and any temporary/intermediary variables that a program creates are implicitly stored on the stack.</li>
<li>Heap segment: This segment is used to store any dynamically allocated data whose size is not known up front and can change at runtime depending on the needs of the program. This is the ideal allocation place when we want values to outlive their declaration within a function.</li>
</ul>
<blockquote>
<p>a process is not allowed to access the physical memory directly. Instead, it uses a virtual memory, which is mapped to the actual physical memory by the OS using an in-memory data structure called pages, which are maintained in page tables. The process has to request memory from the OS for its use, and what it gets is a virtual address that is internally mapped to a physical address in the RAM. For performance reasons, this memory is requested and processed in chunks. When virtual memory is accessed by the process,the memory management unit <em>does the actual conversion from virtual to physical memory</em>.</p>
<p>a process from the OS is known as memory allocation. A process requests <em>a chunk of memory</em> from the OS by using system calls, and the OS marks that chunk of memory in use by that process.</p>
</blockquote>
<h3 id="posix"><a class="header" href="#posix">POSIX</a></h3>
<blockquote>
<p>POSIX is an acronym for Portable Operating System Interface.</p>
</blockquote>
<blockquote>
<p>A GC <em>runs as a daemon thread as part of the running program and analyzes the memory</em> that is no longer being referenced by any variable in the program and frees it automatically at certain points in time along with program execution.</p>
</blockquote>
<h2 id="memory-management-strategies"><a class="header" href="#memory-management-strategies">Memory Management Strategies</a></h2>
<ul>
<li>
<p>Manual: C has his form of memory management, where it’s completely the programmers responsibility to put free calls after the code is done using memory. C++ automates this to some extent using smart pointers where the free call is put in a class’s deconstructor method definition.</p>
</li>
<li>
<p>Automatic: Languages with this form of memory management include an additional runtime thread,that is the Garbage Collector, that runs alongside the program as a daemon thread. Most dynamic languages based on a virtual machine such Python, Java, C# and Ruby rely on automatic memory management. Automatic memory management is one of the reasons that writing code in these languages is easy.</p>
</li>
<li>
<p>[[SemiAutomatic]]: Languages such as Swift fall into this category. They don’t have a dedicated GC built in as part of the runtime, but offer a reference counting type, which does automatic management of memory at a granular level Rust also provides the reference counting types Rc<T> and Arc<T>. </p>
</li>
</ul>
<blockquote>
<p>the majority of  Common Vulnerabilities &amp; Exposure (CVEs) in software related to memory management, it shows that we humans are not very good at this!</p>
</blockquote>
<h3 id="memory-allocator"><a class="header" href="#memory-allocator">Memory Allocator</a></h3>
<blockquote>
<p>the compiler rustc itself uses the jemalloc allocator, whereas the libraries and binaries that are built from Rust use the system allocator. On Linux, it would be the glibc memory allocator APIs. Jemalloc is an efficient allocator library for use in <em>multithreaded</em> environments and it greatly reduces the build time of Rust programs. While jemalloc is used by the compiler, it’s not used by any applications that are built with Rust because it increases the size of the binary. So, compiled binaries and libraries always use the system allocators by default.</p>
</blockquote>
<blockquote>
<p>Rust also has a pluggable allocator design, and can use the system allocator or any user implemented allocator that implements <em>the GlobalAlloc trait</em> from the std::alloc module. This is often implemented by the <em>#[[global_allocator]]</em> attribute, which can be put on any type to declare it as an allocator.
For rare cases where you need to allocate a primitive type on the heap, you can use the Box<T> type, which is a generic smart pointer type.</p>
</blockquote>
<hr />
<blockquote>
<p><code>tags</code> [[segmentation_fault_error]] [[GlobalAlloc]]</p>
</blockquote>
<hr />
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<ul>
<li>The stack actually contains two levels of objects: #stack_frame s and data.</li>
<li>The stack grants programmers access to multiple elements stored within it, rather than the top item only.</li>
<li>The stack can include elements of arbitrary size, where the implication of the dinner plate(exmple theory in book) analogy is that all elements must be of the same size.</li>
</ul>
<blockquote>
<p>So why is the stack called the stack?
Because of the usage pattern. Entries on the stack are made in a Last In, First Out (#LIFO) manner. The entries in the stack are called stack frames. Stack frames are created as function calls are made. As a program progresses, a cursor within the CPU updates to reflect the current address of the current stack frame. </p>
</blockquote>
<blockquote>
<p>one CPU instruction: incrementing/decrementing the stack frame pointer</p>
</blockquote>
<blockquote>
<blockquote>
<p>The #cursor is known as the [[stack_pointer]]. As functions are called within functions, the stack pointer decreases in value as the stack grows. When a function returns, the stack pointer increases.Stack frames contain a function’s state during the call. When a function is called within a function, the older function’s values are effectively frozen in time. Stack frames are also known as activation frames, and less commonly allocation records.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Unlike dinner plates, every stack frame is a different size. </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>The stack frame contains space for its function’s arguments, a pointer to the original call site, and local variables (except the data which is allocated on the heap).</p>
</blockquote>
</blockquote>
<blockquote>
<p>The stack’s primary role is to make space for local variables. Why is the stack fast?</p>
<blockquote>
<p>All of a function’s variables are side by side in memory. That speeds up access.</p>
</blockquote>
</blockquote>
<blockquote>
<p>The stack frame pointer (esp) is a CPU register <em>that always points to the top of the stack</em>. The stack frame pointer keeps on updating as functions get called, or when they return. When a function returns, its stack frame is discarded by restoring the stack frame pointer to where it was before entering the function.</p>
</blockquote>
<h2 id="heap"><a class="header" href="#heap">Heap</a></h2>
<blockquote>
<p>The heap is an area of program memory for types that do not have known sizes at compile time. 
What does it mean to have no known size at compile time? In Rust, there are two meanings. Some types grow and shrink over time as required. </p>
</blockquote>
<blockquote>
<p>Obvious cases are String and Vec<T> . Other types are unable to tell the Rust compiler how much memory to allocate even though these don’t change size at runtime. These are known as dynamically sized types. Slices ([T]) are the commonly cited example. Slices have no compile-time length. Internally, these are a pointer to some part of an array. But slices actually represent some number of elements within that array. Another example is a trait objects.</p>
</blockquote>
<blockquote>
<blockquote>
<p>[[RAII]] stands for Resource Acquisition Is Initialization; a paradigm suggesting that <em>resources must be acquired during initialization of objects and must be released</em> when they are deallocated or their destructors are called.</p>
</blockquote>
</blockquote>
<blockquote>
<p>The only way to allocate memory on the heap is through smart pointer types.</p>
</blockquote>
<blockquote>
<p>The heap memory is to be used with care. Values in the heap can possibly live forever during the lifetime of the program if not freed, and may eventually lead to the program being killed by the Out Of Memory (OOM) killer in the kernel. At runtime, a bug in the code or mistake from the developer can also cause the program to either forget to free the memory, or access a portion of memory that is outside the bounds of its memory layout, or dereference a memory address in the protected code segment. When this happens, the process receives a trap instruction from the kernel, which is what you see as a segmentation fault #error message, followed by the process getting aborted. As such, we must ensure that processes and their interactions with memory need to be safe! Either we as programmers need to be critically aware of our malloc and free calls or used memory safe language to handle these details for us.</p>
</blockquote>
<h2 id="stack-vs-heap"><a class="header" href="#stack-vs-heap">Stack Vs Heap</a></h2>
<ul>
<li>The stack is fast, but the heap is slow.</li>
<li>That difference leads to the following axiom: “When in doubt, prefer the stack.” To place data onto the stack, the compiler must know the type’s size at compile time- Translated to Rust, that means, “When in doubt, use types that implement Sized.”</li>
<li>based on Memory layout image we can say Heap in-replacable space in comprasion of stack that is LIFO</li>
</ul>
<table><thead><tr><th>Stack</th><th>Heap</th></tr></thead><tbody>
<tr><td>Simple</td><td>Complex</td></tr>
<tr><td>Safe</td><td>Dangerous*</td></tr>
<tr><td>Fast</td><td>Slow</td></tr>
<tr><td>Rigid</td><td>Flexible</td></tr>
<tr><td>no cost</td><td>cost of involves dereferencing the pointer</td></tr>
</tbody></table>
<blockquote>
<p>“* Not in safe Rust!”</p>
<p>“ because a function’s local variables“</p>
</blockquote>
<blockquote>
<p>The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating. <em>Pushing values onto the stack is not considered allocating</em>. Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer. Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.</p>
</blockquote>
<blockquote>
<p>Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, <em>allocating space on the heap requires more work, because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.</em></p>
</blockquote>
<h2 id="what-is-dynamic-memory-allocation"><a class="header" href="#what-is-dynamic-memory-allocation">What is dynamic memory allocation?</a></h2>
<blockquote>
<p>At any given time, a running program has a fixed number of bytes with which to get its work done. </p>
<p><em>When the program would like more memory</em>, it needs to ask for more from the OS. </p>
</blockquote>
<blockquote>
<p>Dynamic memory allocation is a three-step process:</p>
</blockquote>
<ul>
<li>Request memory from the OS via a system call. In the UNIX family of operating systems, this system call is alloc(). In MS Windows, the call is HeapAlloc().</li>
<li>Make use of the allocated memory in the program.</li>
<li>Release memory that isn’t needed back to the OS via free() for UNIX systems and HeapFree() for Windows.</li>
</ul>
<h2 id="memory-data-leak"><a class="header" href="#memory-data-leak">Memory Data Leak</a></h2>
<blockquote>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a memory leak). Preventing memory leaks entirely is not one of Rust’s guarantees in the same way that disallowing data races at compile time is, meaning memory leaks are memory safe in Rust. </p>
</blockquote>
<blockquote>
<p>We can see that Rust allows memory leaks by using Rc<T> and RefCell<T>: it’s possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</p>
</blockquote>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h2>
<blockquote>
<p>Safety: cannot point to invalid memory and remain valid in all code paths. In other words, safety basically boils down to pointers having valid references all of the time in your program, and that the operations with pointers do not lead to undefined behavior (#error). </p>
</blockquote>
<blockquote>
<p>Undefined behavior is the state of a program where it has entered a situation that has not been accounted for in the compiler’s because the compiler specification does not clarify what happens in that situation.</p>
</blockquote>
<blockquote>
<p>Languages based on virtual machines use garbage collection to eliminate whole classes of memory safety issues.</p>
</blockquote>
<blockquote>
<p>While Rust doesn’t have a built-in GC, it relies on the same RAII built into the language and makes freeing used memory automatic for us based on the scope of variables and is much more safer than C or C++.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Memory safety bugs lead to memory leaks.</p>
</blockquote>
</blockquote>
<h2 id="deallocating"><a class="header" href="#deallocating">Deallocating</a></h2>
<blockquote>
<p>Note: In C++, this pattern of deallocating resources at the end of an item’s lifetime is sometimes called Resource Acquisition Is Initialization (RAII). The drop function in Rust will be familiar to you if you’ve used RAII patterns.</p>
</blockquote>
<h2 id="double-free"><a class="header" href="#double-free">Double Free</a></h2>
<blockquote>
<p>This is a problem: when s2 and s1 (s2 is copied s1 means 2different pointer and the same data) go out of scope, they will both try to free the same memory. This is known as a #error_double_free and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.</p>
</blockquote>
<h2 id="memory-alignment"><a class="header" href="#memory-alignment">Memory Alignment</a></h2>
<blockquote>
<p>Word size: Word size means the number of bits of data processed by the microprocessor as a unit.</p>
</blockquote>
<blockquote>
<p>Memory access granularity: The minimum chunk of data accessed by the CPU from the memory bus is called the memory access granularity.</p>
</blockquote>
<blockquote>
<p>Data types in all programming languages have both a size and an alignment. The alignment of primitive types is equal to their size. So, usually, all primitive types are aligned and the CPU has no problem doing an aligned read for these. But when we create custom data types, compilers usually insert <em>padding</em> between our struct fields if they are not aligned to allow the CPU to access memory in an aligned manner.</p>
</blockquote>
<h2 id="unrolling"><a class="header" href="#unrolling">UnRolling</a></h2>
<p>// is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // Sample data initialization
    let mut buffer = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130]; // Example buffer values
    let coefficients: [i64; 12] = [
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 // Example coefficients
    ];
    let qlp_shift: i16 = 2; // Example shift value

    // Reference to buffer slice for modification
    let buffer_slice: &amp;mut [i32] = &amp;mut buffer;

    // Implementing the given code snippet
    for i in 12..buffer.len() {
        let prediction = coefficients.iter()
                                     .zip(&amp;buffer_slice[i - 12..i])
                                     .map(|(&amp;c, &amp;s)| c * s as i64)
                                     .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
        let delta = buffer_slice[i];
        buffer_slice[i] = prediction as i32 + delta;
    }

    // Printing the modified buffer
    println!(&quot;Modified Buffer: {:?}&quot;, buffer_slice);
}
//Output: Modified Buffer: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 1755]
</code></pre></pre>
<h2 id="glossery-18"><a class="header" href="#glossery-18">Glossery</a></h2>
<blockquote>
<p><code>stack</code> : contiguous layout memory = LIFO</p>
</blockquote>
<blockquote>
<p><code>tags</code> [[memory_leak]] [[safety]] [[LIFO]]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>[[clp-allocator]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[ria-piston]]</p>
<hr />
<blockquote>
<p>Some general strategies for minimizing heap allocations include</p>
</blockquote>
<ul>
<li>
<p><strong>Using arrays of uninitialized objects</strong>. Instead of creating objects from scratch as required, create a bulk lot of those with zeroed values. When the time comes to activate one of those objects, set its values to non-zero. This can be <em>a very dangerous strategy because you’re circumventing Rust’s lifetime checks</em>.</p>
</li>
<li>
<p>Using an allocator that is tuned for your application’s access memory profile. <strong>Memory allocators</strong> are often sensitive to the sizes where these perform best.</p>
</li>
<li>
<p><strong>Investigate arena::Arena and arena::TypedArena</strong>. These allow objects to be created on the fly, but alloc() and free() are only called when the arena is created and destroyed.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>[[MATH]]</p>
<p>[[FACTORIAL]]</p>
<p>[[FIZZ_BUZZ]]</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[[dtolnay]]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[edu_brain_teaser]]</p>
<h2 id="quick-sort"><a class="header" href="#quick-sort">Quick sort</a></h2>
<p>thread=&gt; race =&gt; rust-doc-thread-rayon-main</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[TBYTE]]</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>[1]</strong> resolve the problem?</p>
<p>[1.x]</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){
let mut favorite_foods = vec! [&quot;potato&quot;, &quot;tomato&quot;];
let mut healthy_foods = &amp;mut favorite_foods;
healthy_foods.push(&quot;carrot&quot;);
let mut grocery_list = &amp;mut favorite_foods;//error[E0499]: cannot borrow `favorite_foods` as mutable more than once at a time
grocery_list.push(&quot;cookies&quot;);
println! (&quot;Healthy Foods: &quot;);
for food in healthy_foods {
    println!(&quot;{}&quot;, food);
}
println! (&quot;Grocery List:&quot;);
for food in grocery_list {
    println!(&quot;{}&quot;, food);
}
}
</code></pre></pre>
<p>[1.1] favorite foods does not need to be mutable.</p>
<p>[1.2] healthy foods does not need to be mutable.</p>
<p>[1.3] favorite foods is already mutable.</p>
<p><strong>[1.4]</strong> favorite foods is mutably borrowed twice.</p>
<hr />
<p><strong>[2]</strong> You’re writing a function that returns the first word of a sentence. But the compiler returns an error. Some lifetimes can be elided, and others must be specified. What lifetimes need to be specified in the function below?</p>
<p><strong>[2.1]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>fn first_word&lt;'a&gt;(sentence: &amp;'a str, separator: &amp;'a str) -&gt; &amp;'a str {
    let word: &amp;'a str = sentence
                            .split(separator)
                            .next()
                            .unwrap();
    word
}
println!(&quot;{}&quot;,first_word(&quot;arman riazi&quot;,&quot; &quot;));
<span class="boring">}
</span></code></pre></pre>
<p>[2.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){
fn first_word(sentence: &amp;str, separator: &amp;str) -&gt; &amp;str {
    let word: &amp;'a str = sentence
                            .split(separator)
                            .next()
                            .unwrap();
    word
}

println!(&quot;{}&quot;,first_word(&quot;arman riazi&quot;,&quot; &quot;));
}
</code></pre></pre>
<p>[2.3]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>    fn first_word&lt;'a&gt;(sentence: &amp;str, separator:  &amp;str) -&gt; &amp;'a str {
    let word: &amp;str = sentence
                            .split(separator)
                            .next()
                            .unwrap();
        word
    }
    println!(&quot;{}&quot;,first_word(&quot;arman riazi&quot;,&quot; &quot;));
<span class="boring">}
</span></code></pre></pre>
<p>[2.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>    fn first_word&lt;'a&gt;(sentence: &amp;'a str, separator:  &amp;'a str) -&gt; &amp;str {
    let word: &amp;str = sentence
                            .split(separator)
                            .next()
                            .unwrap();
        word
    }
    println!(&quot;{}&quot;,first_word(&quot;arman riazi&quot;,&quot; &quot;));
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[3]</strong> You want to count the letters in a word. Choose the best option?</p>
<p><strong>[3.1]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){
    use std::collections::HashMap;
    let word = &quot;internationalization&quot;;
    let mut letter_count = HashMap::new();

    for letter in word.chars() {

        let count = letter_count.entry (letter).or_insert(0);
        *count += 1;
    }
    for (letter, count) in &amp;letter_count {
        println!(&quot;{}: {}&quot;, letter, count);
    }
}
</code></pre></pre>
<p>[3.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>    use std::collections::HashMap;
    let word = &quot;internationalization&quot;;
    let mut letter_count = HashMap::new();

    for letter in word.chars() {
            match &amp;mut letter_count.get(&amp;letter) {
                Some (count) =&gt; *count += 1,
        }
         =&gt; {letter_count.insert(letter, 1);},
    }    
    for (letter, count) in &amp;letter_count {
        println!(&quot;{}: {}&quot;, letter, count);
    }
<span class="boring">}
</span></code></pre></pre>
<p>[3.3]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>    use std::collections::HashMap;
    let word = &quot;internationalization&quot;;
    let mut letter_count = HashMap::new();

    for letter in word.chars() {                    
        if let Some (count) = letter_count.get(&amp;letter) {
               letter_count.insert(letter, count + 1);
           } else {
            letter_count.insert(letter, 1);
        }        
    }
    for (letter, count) in &amp;letter_count {
        println!(&quot;{}: {}&quot;, letter, count);
    }
<span class="boring">}
</span></code></pre></pre>
<p>[3.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>    use std::collections::HashMap;
    let word = &quot;internationalization&quot;;
    let mut letter_count = HashMap::new();

    for letter in word.chars() {                    
      match &amp;mut letter_count.get(&amp;letter){
        Some(count)=&gt; *count +=1,
        _ =&gt; {letter_count.insert(letter,1);}
      }
    }
    for (letter, count) in &amp;letter_count {
        println!(&quot;{}: {}&quot;, letter, count);
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>[4]</strong> You have a program to show the best vacation spots. It has multiple threads so eventually the API team will update the list separately from the UX team. How does move help us write better code in this code snippet?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>let mut vacation_spots= vec! [&quot;New York City&quot;, &quot;Yosemite&quot;, &quot;Monterey&quot;];
let handle = std::thread::spawn( move || {
    for spot in vacation_spots {
        println!(&quot;{}&quot;, spot);
    }
    });
    vacation_spots.remove(1);// Error value borrowed here after move
    handle.join().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>[4.1] The value vacation_spots was moved and then mutated in another thread. This helps us prevent race conditions.</p>
<p>[4.2] Without the move keyword, the join().unwrap() would always panic. This helps us write code that does not panic.</p>
<p><strong>[4.3]</strong> Without the move keyword, the compiler wouldn’t know the thread might use vacation_spots after it was mutated. This helps us prevent borrowing after moving values.</p>
<p>[4.4] The closure is moved. This helps us make sure the closure used only once.</p>
<hr />
<p><strong>[5]</strong> What does the following program do?</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;
use std::io::{self, Write};
use std::process::{Command, Stdio};

fn go_wc() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Spawn the 'echo' command and capture its output
    let mut echo = Command::new(&quot;echo&quot;)
       .arg(&quot;one two three&quot;)
       .stdout(Stdio::piped())
       .spawn()?;

    // Capture the stdout of 'echo' command
    let mut echo_output = echo.stdout.take().expect(&quot;Failed to take stdout&quot;);

    // Spawn the 'wc' command, piping its stdin from the 'echo' command's stdout
    let mut wc = Command::new(&quot;wc&quot;)
       .arg(&quot;-w&quot;) // Count words
       .stdin(Stdio::piped())
       .stdout(Stdio::inherit()) // Inherit stdout so we can see the output
       .spawn()?;

    // Write the output of 'echo' to the stdin of 'wc'
    io::copy(&amp;mut echo_output, &amp;mut wc.stdin.take().expect(&quot;Failed to take stdin&quot;))?;

    Ok(())
}

fn main() {
    match go_wc() {
        Ok(_) =&gt; println!(&quot;Success&quot;),
        Err(e) =&gt; eprintln!(&quot;Error: {}&quot;, e),
    }
}
</code></pre></pre>
<blockquote>
<p><strong>[5.1]</strong></p>
</blockquote>
<ol>
<li>Pipes echo’s stdout to the program’s stdin. </li>
<li>Pipes the program’s stdin into wc.</li>
<li>Copies echo’s stdout into wc’s stdin.</li>
</ol>
<blockquote>
<p>[5.2]</p>
</blockquote>
<ol>
<li>Starts echo.</li>
<li>Pipes wc’s stdout to the program’s stdout. </li>
<li>Copies echo’s stdout into wc’s stdin.</li>
</ol>
<blockquote>
<p>[5.3]</p>
</blockquote>
<ol>
<li>Pipes the program’s stdin into echo. </li>
<li>Pipes wc’s stdout to the program’s stdin. </li>
<li>Copies echo’s stdout into wc’s stdin.</li>
</ol>
<blockquote>
<p>[5.4]</p>
</blockquote>
<ol>
<li>Starts echo.</li>
<li>Starts wc.</li>
<li>Copies echo’s stdout into wc’s stdin. </li>
<li>Nothing is printed to the console.</li>
</ol>
<hr />
<p><strong>[6]</strong> Which of the following snippetes sets result to the number 12?</p>
<p>[6.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>let numbers = [1,3,6];
let result: u32 = numbers
            .iter()
            .filter(|&amp;x| x % 2 ==0)
            .flat_map(|x| x *  2)
            .sum();
assert_eq!(result,12);
<span class="boring">}
</span></code></pre></pre>
<p><strong>[6.2]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>let numbers = [1,3,6];
let result: u32 = numbers
            .iter()
            .filter(|&amp;x| x % 2 ==0)
            .map(|x| x *  2)
            .sum();
assert_eq!(result,12);
<span class="boring">}
</span></code></pre></pre>
<p>[6.3]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>let numbers = [1,3,6];
let result: u32 = numbers
            .iter()            
            .map(|x| x *  2)
            .filter(|x| x % 2 == 0)
            .sum();
assert_eq!(result,12);
<span class="boring">}
</span></code></pre></pre>
<p>[6.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring"> fn main(){
</span>let numbers = [1,3,6];
let result: u32 = numbers
            .iter()            
            .skip(1)
            .take(1)
            .map(|x| x *  2)            
            .sum();
assert_eq!(result,12);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[7]</strong> How can you pass a string to these functions?</p>
<p>[7.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let name : String= &quot;Smith&quot;.to_string();
greet_person(name);
show_schedule(name);
<span class="boring">}
</span>fn greet_person(name:String){
    println!(&quot;Hello {}&quot;,name);
}
fn show_schedule(name:String){
    println!(&quot;{}'s schedule is : A,B,C&quot;,name);
}
</code></pre></pre>
<p>[7.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let name : &amp;str = &quot;Smith&quot;;
greet_person(name);
show_schedule(name);
<span class="boring">}
</span>fn greet_person(name:String){
    println!(&quot;Hello {}&quot;,name);
}
fn show_schedule(name:String){
    println!(&quot;{}'s schedule is : A,B,C&quot;,name);
}
</code></pre></pre>
<p><strong>[7.3]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let name : &amp;str = &quot;Smith&quot;;
greet_person(name);
show_schedule(name);
<span class="boring">}
</span>fn greet_person(name:&amp;str){
    println!(&quot;Hello {}&quot;,name);
}
fn show_schedule(name:&amp;str){
    println!(&quot;{}'s schedule is : A,B,C&quot;,name);
}
</code></pre></pre>
<p>[7.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let name : String= String::from(&quot;Smith&quot;);
greet_person(name);
show_schedule(name);
<span class="boring">}
</span>fn greet_person(name:String){
    println!(&quot;Hello {}&quot;,name);
}
fn show_schedule(name:String){
    println!(&quot;{}'s schedule is : A,B,C&quot;,name);
}
</code></pre></pre>
<hr />
<p><strong>[8]</strong> Which of the following is <strong>NOT equvalent</strong>  to the trait bounds below?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn communicate&lt;T: Speak + Listen&gt;(thing: &amp;T){
    //..
}
<span class="boring">}
</span></code></pre></pre>
<p>[8.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn communicate&lt;T&gt;(thing: &amp;T)
    where T: Speak,
          T: Listen
{
    //..
}
<span class="boring">}
</span></code></pre></pre>
<p>[8.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn communicate&lt;T&gt;(thing: &amp;(impl Speak + Listen)){
    //..
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[8.3]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn communicate&lt;T&gt;(thing: &amp;(Speak + Listen)){
    //..
}
<span class="boring">}
</span></code></pre></pre>
<p>[8.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn communicate&lt;T&gt;(thing: &amp;T){
    where T: Speak + Listen
    //..
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[9]</strong> How can you modify as item in Vec inside a loop?</p>
<p>[9.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Items{
</span><span class="boring">   is_ordered:bool
</span><span class="boring">}
</span><span class="boring">fn main(){
</span><span class="boring">   let it1= Items{is_ordered:true};
</span><span class="boring">   let it2= Items{is_ordered:true};
</span><span class="boring">   let items: Vec&lt;Items&gt;= vec![it1,it2];
</span>    for item in &amp;mut items{
        item.is_ordered = true;
    }
<span class="boring">}
</span></code></pre></pre>
<p>[9.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Items{
</span><span class="boring">   is_ordered:bool
</span><span class="boring">}
</span><span class="boring">fn main(){
</span><span class="boring">   let it1= Items{is_ordered:true};
</span><span class="boring">   let it2= Items{is_ordered:true};
</span><span class="boring">   let items: Vec&lt;Items&gt;= vec![it1,it2];
</span>    for mut item in &amp;items{
        item.is_ordered = true;
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>[9.3]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"> #[derive(Debug)]
 struct Items{
    is_ordered:bool
 }
 fn main(){
    let it1= Items{is_ordered:true};
    let it2= Items{is_ordered:true};
    let items: Vec&lt;Items&gt;= vec![it1,it2];
   for mut item in items{
       item.is_ordered = true;
   }
 }
</code></pre></pre>
<p>[9.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Items{
</span><span class="boring">   is_ordered:bool
</span><span class="boring">}
</span><span class="boring">fn main(){
</span><span class="boring">   let it1= Items{is_ordered:true};
</span><span class="boring">   let it2= Items{is_ordered:true};
</span><span class="boring">   let items: Vec&lt;Items&gt;= vec![it1,it2];
</span>    for &amp;mut item in items{
        item.is_ordered = true;
    }
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[10]</strong> Which code snippet works?</p>
<p>[10.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span> enum Staff{
    CEO,
    Employee { boss: Option&lt;Staff&gt; } 
 }
<span class="boring">fn main(){
</span>   let s= Staff:: Employee;
<span class="boring">}
</span></code></pre></pre>
<p>[10.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span> enum Staff{
    CEO,
    Employee { boss: Staff } 
 }
<span class="boring">fn main(){
</span>   let s= Staff:: Employee;
<span class="boring">}
</span></code></pre></pre>
<p>[10.3]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span> enum Staff{    
    boss: Option&lt;Staff&gt;
 }
<span class="boring">fn main(){
</span>   let s= Staff::boss;
<span class="boring">}
</span></code></pre></pre>
<p><strong>[10.4]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Employee{
    boss: Staff
}
 enum Staff{    
    CEO,
    Regular(Employee),
 }
<span class="boring">fn main(){
</span>   let s= Staff::Regular;
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[11]</strong> You have some data that needs to be processed multi-threaded. However when trying to save the data into a HashMap the compiler throws an error saying hash_map was moved. How do you synchronize and get data out of threads?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let mut hash_map: std::collections::HashMap&lt;u32, u32&gt;= std::collections::HashMap::new();
for i in 1..=3 {
    std::thread::spawn (move || { //error 
                    let result = i * 7;
                    hash_map.insert(i, result);
                });
}
for (i, number) in &amp;hash_map {
    println!(&quot;{}* 7 = {}&quot;, i, number);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[11.1]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let thread_count = 3;
let (tx, rx) = std::sync::mpsc::channel();
for i in 1..=thread_count {
    let tx = tx.clone();
    std::thread::spawn (move || {
        let result = i * 7;
        let _= tx.send((i, result));
    });
}
    for _ in 1..=thread_count {
        let (i, number) = rx.recv().unwrap();
        println!(&quot;{}* 7 = {}&quot;, i, number);
    }
<span class="boring">}
</span></code></pre></pre>
<p>[11.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let mutex = std::sync::Mutex::new(std::collections::HashMap::new());
 let mut handles = vec! [];
for i in 1..3 {
    let handle = std::thread::spawn (move || {
        let result = i * 7;
        mutex.lock().unwrap().insert(i, result);
    });
    handles.push(handle);
}
for child in handles {
    let _= child.join();
}
let hash_map=mutex.lock().unwrap();
for (i, number) in &amp;(*hash_map) {
    println!(&quot;{}* 7 = {}&quot;, i, number);
}
<span class="boring">}
</span></code></pre></pre>
<p>[11.3]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>use std::sync:: {Arc, Mutex};
let hash_map = Arc::new(Mutex::new(std::collections::HashMap::new()));
for i in 1..3 {
    let arc_map = hash_map.clone();
    std::thread::spawn (move || {
        let result = i * 7;
        arc_map.lock().unwrap().insert(i, result);
    });
}
for (i, number) in &amp;(*hash_map.lock().unwrap()) {
    println!(&quot;{}* 7 = {}&quot;, i, number);
}
<span class="boring">}
</span></code></pre></pre>
<p>[11.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let mut hash_map: std::collections::HashMap&lt;u32, u32&gt;= std::collections::HashMap::new();
for i in 1..=3 {
    let mut result = 0;
    std::thread::spawn (move || {
        result = i * 7;
    });
     hash_map.insert(i, result);
}
for (i, number) in &amp;hash_map {
    println!(&quot;{}* 7 = {}&quot;, i, number);
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[12]</strong> What is the output this puzzle?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let a = Some(&quot;a&quot;);
let b = Some(&quot;b&quot;);
let c = Some(&quot;c&quot;);
let d = Some(&quot;d&quot;);
let a_or_d = a.unwrap_or (d.unwrap());
//println!(&quot;a_or_d  {}&quot;, a_or_d.clone()); //return a
let default_not = || b.iter().next(); //return NONE
let c_mapped = |_| Some(&amp;a_or_d);
let result= c.map_or_else(default_not, c_mapped).unwrap();
println!(&quot;Result {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<p><strong>[12.1]</strong>
a
[12.2]
b
[12.3]
thread ‘main’ panicked at ’called ‘Option: : unwrap()’ on a ‘None’ value’, src/main.rs:13:7’
[12.4]
d</p>
<hr />
<p><strong>[13]</strong> There is a logging function called log that takes a message: &amp;str argument. You need to use this function to print “123”. Which of the following methods work?</p>
<p>[13.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>
fn log(message: &amp;str) {
println!(&quot;{}&quot;, message);
}

let numbers = &quot;123&quot;;
log(&amp;numbers[0..4]);
<span class="boring">}
</span></code></pre></pre>
<p>[13.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>
fn log(message: &amp;str) {
println!(&quot;{}&quot;, message);
}

let numbers = &quot;0123&quot;;
log(&amp;numbers[1:4]);
<span class="boring">}
</span></code></pre></pre>
<p><strong>[13.3]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>
fn log(message: &amp;str) {
println!(&quot;{}&quot;, message);
}

let numbers = &quot;1234&quot;;
log(&amp;numbers[..3]);
<span class="boring">}
</span></code></pre></pre>
<p>[13.4]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>
fn log(message: &amp;str) {
println!(&quot;{}&quot;, message);
}

let numbers = &quot;01234&quot;;
log(&amp;numbers[1..4]);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[14]</strong> You want to print the status of a request in the following format:</p>
<blockquote>
<p><code>success: true, errors: 0, message: success</code></p>
</blockquote>
<blockquote>
<p>Which of the following is <strong>NOT valid Rust</strong>?</p>
</blockquote>
<p>[14.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let result = (true, 0, &quot;success&quot;);
let (success, errors, message) = result;
println!(&quot;success: {}, errors: {}, message: {}&quot;, success, errors, message);
<span class="boring">}
</span></code></pre></pre>
<p>[14.2]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let result: (bool, i32, &amp;str) = (true, 0, &quot;success&quot;);
println! (&quot;success: {}, errors: {}, message: {}&quot;, result.0, result.1, result.2);
<span class="boring">}
</span></code></pre></pre>
<p>[14.3]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let result = (true, 0, &quot;success&quot;);
println! (&quot;success: {}, errors: {}, message: {}&quot;, result.0, result.1, result.2);
<span class="boring">}
</span></code></pre></pre>
<p><strong>[14.4]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>let result = [true, 0, &quot;success&quot;];
println! (&quot;success: {}, errors: {}, message: {}&quot;, result[0], result[1], result[2]);
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[15]</strong> went on vacation, and the lead developer is not happy with the work they delivered below. The lead says the code “crashes all over the place, hides the issue from the calling function, and panics unrecoverably. They needed an expert so they called you in to fix it. Which function will you deliver?</p>
<p>[15.1]</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>fn export_todo (filename: &amp;str, todo_list: &amp;[&amp;str], done_list: &amp;[&amp;str]) {
    let mut file= match std::fs::File::create(filename) {
        Err(e) =&gt; panic!(&quot;{}&quot;, e),
        Ok (f) =&gt; f,
    };

    match file.write_all( b&quot;# To Do List\n&quot;) {
        Err(e) =&gt; panic!(&quot;{}&quot;, e),
        Ok (()) =&gt; (),
    }
    match file.write_all(b&quot;## Next\n&quot;) {
        Err(e) =&gt; panic!(&quot;{}&quot;, e),
        Ok(()) =&gt; (),
    }
    for item in todo_list.iter() {
        match file.write_all(format! (&quot;- [] {}\n&quot;, item).as_bytes()) {
            Err(e) =&gt; panic!(&quot;{}&quot;, e),
            Ok (()) =&gt; (),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>[15.2]</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main(){
</span>    use std::io::Write;
    //Because of return std::io::Result&lt;()&gt; is a good answer. anyoption that do not have Result will not be answer
    fn export_todo(filename: &amp;str, todo_list: &amp;[&amp;str], done_list: &amp;[&amp;str]) -&gt; std::io::Result&lt;()&gt; {

        let mut file = std::fs::File::create(filename)?;
        file.write_all(b&quot;# To Do List \n&quot;)?;
        file.write_all(b&quot;## Next\n&quot;)?;

        for item in todo_list.iter() {
            file.write_all(format! (&quot;- [ ] {}\n&quot;, item).as_bytes())?
        }

        file.write_all(b&quot;## Done\n&quot;)?;
        for item in done_list.iter() {
            file.write_all(format! (&quot;- [x] {}\n&quot;, item).as_bytes())?
        }
    Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<hr />
<p><strong>[16]</strong> Your friend that runs a tool rental company needs a program to calculate customer orders. What is the grand total printed by this program?</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Rental {
    rate: u32,
    days: u32,
    half_off: bool,
}
impl Rental {
 fn subtotal(&amp;self) -&gt; u32 {
    let subtotal = self.rate * self.days;
    if self.half_off {
        return subtotal / 2;
    }
  subtotal
 }
}
fn main(){
    let days = 10;
    let saw = Rental{days, rate: 15, half_off: false };
    let drill = Rental{rate:10, ..saw};
    let trailer = Rental{ half_off: true, ..drill};
    let mut grand_total=0;
    for rental in [saw, drill, trailer].iter() {
        grand_total += rental.subtotal();
    }
println! (&quot;grand total: ${}&quot;, grand_total);
}
</code></pre></pre>
<p><strong>[16.1]</strong> grand total: $300
[16.2] grand total: $125
[16.3] grand total: $150
[16.4] This is not valid rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[[GRAPH]]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
